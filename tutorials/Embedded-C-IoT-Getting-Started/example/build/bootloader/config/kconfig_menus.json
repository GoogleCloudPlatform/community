[
    {
        "children": [], 
        "depends_on": null, 
        "help": null, 
        "id": "IDF_TARGET_ESP32", 
        "name": "IDF_TARGET_ESP32", 
        "range": null, 
        "title": null, 
        "type": "bool"
    }, 
    {
        "children": [], 
        "depends_on": null, 
        "help": null, 
        "id": "IDF_CMAKE", 
        "name": "IDF_CMAKE", 
        "range": null, 
        "title": null, 
        "type": "bool"
    }, 
    {
        "children": [], 
        "depends_on": null, 
        "help": null, 
        "id": "IDF_TARGET_ENV", 
        "name": "IDF_TARGET_ENV", 
        "range": null, 
        "title": null, 
        "type": "string"
    }, 
    {
        "children": [], 
        "depends_on": null, 
        "help": null, 
        "id": "IDF_TARGET", 
        "name": "IDF_TARGET", 
        "range": null, 
        "title": null, 
        "type": "string"
    }, 
    {
        "children": [], 
        "depends_on": null, 
        "help": null, 
        "id": "IDF_FIRMWARE_CHIP_ID", 
        "name": "IDF_FIRMWARE_CHIP_ID", 
        "range": null, 
        "title": null, 
        "type": "hex"
    }, 
    {
        "children": [
            {
                "children": [], 
                "depends_on": null, 
                "help": "The prefix/path that is used to call the toolchain. The default setting assumes\na crosstool-ng gcc setup that is in your PATH.\n", 
                "id": "SDK_TOOLPREFIX", 
                "name": "SDK_TOOLPREFIX", 
                "range": null, 
                "title": "Compiler toolchain path/prefix", 
                "type": "string"
            }, 
            {
                "children": [], 
                "depends_on": "!IDF_CMAKE", 
                "help": "The executable name/path that is used to run python.\n\n(Note: This option is used with the legacy GNU Make build system only.)\n", 
                "id": "SDK_PYTHON", 
                "name": "SDK_PYTHON", 
                "range": null, 
                "title": "Python interpreter", 
                "type": "string"
            }, 
            {
                "children": [], 
                "depends_on": "!IDF_CMAKE", 
                "help": "Adds --warn-undefined-variables to MAKEFLAGS. This causes make to\nprint a warning any time an undefined variable is referenced.\n\nThis option helps find places where a variable reference is misspelled\nor otherwise missing, but it can be unwanted if you have Makefiles which\ndepend on undefined variables expanding to an empty string.\n\n(Note: this option is used with the legacy GNU Make build system only.)\n", 
                "id": "SDK_MAKE_WARN_UNDEFINED_VARIABLES", 
                "name": "SDK_MAKE_WARN_UNDEFINED_VARIABLES", 
                "range": null, 
                "title": "'make' warns on undefined variables", 
                "type": "bool"
            }
        ], 
        "depends_on": null, 
        "id": "sdk-tool-configuration", 
        "title": "SDK tool configuration", 
        "type": "menu"
    }, 
    {
        "children": [
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": "<choice BOOTLOADER_LOG_LEVEL>", 
                        "help": null, 
                        "id": "BOOTLOADER_LOG_LEVEL_NONE", 
                        "name": "BOOTLOADER_LOG_LEVEL_NONE", 
                        "range": null, 
                        "title": "No output", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice BOOTLOADER_LOG_LEVEL>", 
                        "help": null, 
                        "id": "BOOTLOADER_LOG_LEVEL_ERROR", 
                        "name": "BOOTLOADER_LOG_LEVEL_ERROR", 
                        "range": null, 
                        "title": "Error", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice BOOTLOADER_LOG_LEVEL>", 
                        "help": null, 
                        "id": "BOOTLOADER_LOG_LEVEL_WARN", 
                        "name": "BOOTLOADER_LOG_LEVEL_WARN", 
                        "range": null, 
                        "title": "Warning", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice BOOTLOADER_LOG_LEVEL>", 
                        "help": null, 
                        "id": "BOOTLOADER_LOG_LEVEL_INFO", 
                        "name": "BOOTLOADER_LOG_LEVEL_INFO", 
                        "range": null, 
                        "title": "Info", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice BOOTLOADER_LOG_LEVEL>", 
                        "help": null, 
                        "id": "BOOTLOADER_LOG_LEVEL_DEBUG", 
                        "name": "BOOTLOADER_LOG_LEVEL_DEBUG", 
                        "range": null, 
                        "title": "Debug", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice BOOTLOADER_LOG_LEVEL>", 
                        "help": null, 
                        "id": "BOOTLOADER_LOG_LEVEL_VERBOSE", 
                        "name": "BOOTLOADER_LOG_LEVEL_VERBOSE", 
                        "range": null, 
                        "title": "Verbose", 
                        "type": "bool"
                    }
                ], 
                "depends_on": null, 
                "help": "Specify how much output to see in bootloader logs.\n", 
                "id": "bootloader-config-bootloader-log-verbosity", 
                "name": "BOOTLOADER_LOG_LEVEL", 
                "title": "Bootloader log verbosity", 
                "type": "choice"
            }, 
            {
                "children": [], 
                "depends_on": null, 
                "help": null, 
                "id": "BOOTLOADER_LOG_LEVEL", 
                "name": "BOOTLOADER_LOG_LEVEL", 
                "range": null, 
                "title": null, 
                "type": "int"
            }, 
            {
                "children": [], 
                "depends_on": "ESPTOOLPY_FLASHMODE_QIO || ESPTOOLPY_FLASHMODE_QOUT", 
                "help": "This value is ignored unless flash mode is set to QIO or QOUT *and* the SPI flash pins have been\noverriden by setting the eFuses SPI_PAD_CONFIG_xxx.\n\nWhen this is the case, the eFuse config only defines 3 of the 4 Quad I/O data pins. The WP pin (aka ESP32\npin \"SD_DATA_3\" or SPI flash pin \"IO2\") is not specified in eFuse. That pin number is compiled into the\nbootloader instead.\n\nThe default value (GPIO 7) is correct for WP pin on ESP32-D2WD integrated flash.\n", 
                "id": "BOOTLOADER_SPI_WP_PIN", 
                "name": "BOOTLOADER_SPI_WP_PIN", 
                "range": null, 
                "title": "SPI Flash WP Pin when customising pins via eFuse (read help)", 
                "type": "int"
            }, 
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": "!ESPTOOLPY_FLASHFREQ_80M && <choice BOOTLOADER_VDDSDIO_BOOST>", 
                        "help": null, 
                        "id": "BOOTLOADER_VDDSDIO_BOOST_1_8V", 
                        "name": "BOOTLOADER_VDDSDIO_BOOST_1_8V", 
                        "range": null, 
                        "title": "1.8V", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice BOOTLOADER_VDDSDIO_BOOST>", 
                        "help": null, 
                        "id": "BOOTLOADER_VDDSDIO_BOOST_1_9V", 
                        "name": "BOOTLOADER_VDDSDIO_BOOST_1_9V", 
                        "range": null, 
                        "title": "1.9V", 
                        "type": "bool"
                    }
                ], 
                "depends_on": null, 
                "help": "If this option is enabled, and VDDSDIO LDO is set to 1.8V (using eFuse\nor MTDI bootstrapping pin), bootloader will change LDO settings to\noutput 1.9V instead. This helps prevent flash chip from browning out\nduring flash programming operations.\n\nThis option has no effect if VDDSDIO is set to 3.3V, or if the internal\nVDDSDIO regulator is disabled via eFuse.\n", 
                "id": "bootloader-config-vddsdio-ldo-voltage", 
                "name": "BOOTLOADER_VDDSDIO_BOOST", 
                "title": "VDDSDIO LDO voltage", 
                "type": "choice"
            }, 
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": "BOOTLOADER_FACTORY_RESET", 
                        "help": "The selected GPIO will be configured as an input with internal pull-up enabled.\nTo trigger a factory reset, this GPIO must be pulled low on reset.\nNote that GPIO34-39 do not have an internal pullup and an external one must be provided.\n", 
                        "id": "BOOTLOADER_NUM_PIN_FACTORY_RESET", 
                        "name": "BOOTLOADER_NUM_PIN_FACTORY_RESET", 
                        "range": null, 
                        "title": "Number of the GPIO input for factory reset", 
                        "type": "int"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "BOOTLOADER_FACTORY_RESET", 
                        "help": "The device will boot from \"factory\" partition (or OTA slot 0 if no factory partition is present) after a\nfactory reset.\n", 
                        "id": "BOOTLOADER_OTA_DATA_ERASE", 
                        "name": "BOOTLOADER_OTA_DATA_ERASE", 
                        "range": null, 
                        "title": "Clear OTA data on factory reset (select factory partition)", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "BOOTLOADER_FACTORY_RESET", 
                        "help": "Allows customers to select which data partitions will be erased while factory reset.\n\nSpecify the names of partitions as a comma-delimited with optional spaces for readability. (Like this:\n\"nvs, phy_init, ...\")\nMake sure that the name specified in the partition table and here are the same.\nPartitions of type \"app\" cannot be specified here.\n", 
                        "id": "BOOTLOADER_DATA_FACTORY_RESET", 
                        "name": "BOOTLOADER_DATA_FACTORY_RESET", 
                        "range": null, 
                        "title": "Comma-separated names of partitions to clear on factory reset", 
                        "type": "string"
                    }
                ], 
                "depends_on": null, 
                "help": "Allows to reset the device to factory settings:\n- clear one or more data partitions;\n- boot from \"factory\" partition.\nThe factory reset will occur if there is a GPIO input pulled low while device starts up.\nSee settings below.\n", 
                "id": "BOOTLOADER_FACTORY_RESET", 
                "name": "BOOTLOADER_FACTORY_RESET", 
                "range": null, 
                "title": "GPIO triggers factory reset", 
                "type": "bool"
            }, 
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": "BOOTLOADER_APP_TEST", 
                        "help": "The selected GPIO will be configured as an input with internal pull-up enabled.\nTo trigger a test app, this GPIO must be pulled low on reset.\nAfter the GPIO input is deactivated and the device reboots, the old application will boot.\n(factory or OTA[x]).\nNote that GPIO34-39 do not have an internal pullup and an external one must be provided.\n", 
                        "id": "BOOTLOADER_NUM_PIN_APP_TEST", 
                        "name": "BOOTLOADER_NUM_PIN_APP_TEST", 
                        "range": null, 
                        "title": "Number of the GPIO input to boot TEST partition", 
                        "type": "int"
                    }
                ], 
                "depends_on": null, 
                "help": "Allows to run the test app from \"TEST\" partition.\nA boot from \"test\" partition will occur if there is a GPIO input pulled low while device starts up.\nSee settings below.\n", 
                "id": "BOOTLOADER_APP_TEST", 
                "name": "BOOTLOADER_APP_TEST", 
                "range": null, 
                "title": "GPIO triggers boot from test app partition", 
                "type": "bool"
            }, 
            {
                "children": [], 
                "depends_on": "BOOTLOADER_FACTORY_RESET || BOOTLOADER_APP_TEST", 
                "help": "The GPIO must be held low continuously for this period of time after reset\nbefore a factory reset or test partition boot (as applicable) is performed.\n", 
                "id": "BOOTLOADER_HOLD_TIME_GPIO", 
                "name": "BOOTLOADER_HOLD_TIME_GPIO", 
                "range": null, 
                "title": "Hold time of GPIO for reset/test mode (seconds)", 
                "type": "int"
            }, 
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": "BOOTLOADER_WDT_ENABLE", 
                        "help": "If it is set, the client must itself reset or disable rtc_wdt in their code (app_main()).\nOtherwise rtc_wdt will be disabled before calling app_main function.\nUse function rtc_wdt_feed() for resetting counter of rtc_wdt.\nUse function rtc_wdt_disable() for disabling rtc_wdt.\n", 
                        "id": "BOOTLOADER_WDT_DISABLE_IN_USER_CODE", 
                        "name": "BOOTLOADER_WDT_DISABLE_IN_USER_CODE", 
                        "range": null, 
                        "title": "Allows RTC watchdog disable in user code", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "BOOTLOADER_WDT_ENABLE", 
                        "help": "Verify that this parameter is correct and more then the execution time.\nPay attention to options such as reset to factory, trigger test partition and encryption on boot\n- these options can increase the execution time.\nNote: RTC_WDT will reset while encryption operations will be performed.\n", 
                        "id": "BOOTLOADER_WDT_TIME_MS", 
                        "name": "BOOTLOADER_WDT_TIME_MS", 
                        "range": [
                            0, 
                            120000
                        ], 
                        "title": "Timeout for RTC watchdog (ms)", 
                        "type": "int"
                    }
                ], 
                "depends_on": null, 
                "help": "Tracks the execution time of startup code.\nIf the execution time is exceeded, the RTC_WDT will restart system.\nIt is also useful to prevent a lock up in start code caused by an unstable power source.\nNOTE: Tracks the execution time starts from the bootloader code - re-set timeout, while selecting the\nsource for slow_clk - and ends calling app_main.\nRe-set timeout is needed due to WDT uses a SLOW_CLK clock source. After changing a frequency slow_clk a\ntime of WDT needs to re-set for new frequency.\nslow_clk depends on ESP32_RTC_CLK_SRC (INTERNAL_RC or EXTERNAL_CRYSTAL).\n", 
                "id": "BOOTLOADER_WDT_ENABLE", 
                "name": "BOOTLOADER_WDT_ENABLE", 
                "range": null, 
                "title": "Use RTC watchdog in start code", 
                "type": "bool"
            }, 
            {
                "children": [
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "BOOTLOADER_APP_ANTI_ROLLBACK", 
                                "help": "The secure version is the sequence number stored in the header of each firmware.\nThe security version is set in the bootloader, version is recorded in the eFuse field\nas the number of set ones. The allocated number of bits in the efuse field\nfor storing the security version is limited (see BOOTLOADER_APP_SEC_VER_SIZE_EFUSE_FIELD option).\n\nBootloader: When bootloader selects an app to boot, an app is selected that has\na security version greater or equal that recorded in eFuse field.\nThe app is booted with a higher (or equal) secure version.\n\nThe security version is worth increasing if in previous versions there is\na significant vulnerability and their use is not acceptable.\n\nYour partition table should has a scheme with ota_0 + ota_1 (without factory).\n", 
                                "id": "BOOTLOADER_APP_SECURE_VERSION", 
                                "name": "BOOTLOADER_APP_SECURE_VERSION", 
                                "range": null, 
                                "title": "eFuse secure version of app", 
                                "type": "int"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "BOOTLOADER_APP_ANTI_ROLLBACK", 
                                "help": "The size of the efuse secure version field. Its length is limited to 32 bits.\nThis determines how many times the security version can be increased.\n", 
                                "id": "BOOTLOADER_APP_SEC_VER_SIZE_EFUSE_FIELD", 
                                "name": "BOOTLOADER_APP_SEC_VER_SIZE_EFUSE_FIELD", 
                                "range": null, 
                                "title": "Size of the efuse secure version field", 
                                "type": "int"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "BOOTLOADER_APP_ANTI_ROLLBACK", 
                                "help": "This option allow emulate read/write operations with efuse secure version.\nIt allow to test anti-rollback implemention without permanent write eFuse bits.\nIn partition table should be exist this partition `emul_efuse, data, 5, , 0x2000`.\n", 
                                "id": "BOOTLOADER_EFUSE_SECURE_VERSION_EMULATE", 
                                "name": "BOOTLOADER_EFUSE_SECURE_VERSION_EMULATE", 
                                "range": null, 
                                "title": "Emulate operations with efuse secure version(only test)", 
                                "type": "bool"
                            }
                        ], 
                        "depends_on": "BOOTLOADER_APP_ROLLBACK_ENABLE", 
                        "help": "This option prevents rollback to previous firmware/application image with lower security version.\n", 
                        "id": "BOOTLOADER_APP_ANTI_ROLLBACK", 
                        "name": "BOOTLOADER_APP_ANTI_ROLLBACK", 
                        "range": null, 
                        "title": "Enable app anti-rollback support", 
                        "type": "bool"
                    }
                ], 
                "depends_on": null, 
                "help": "After updating the app, the bootloader runs a new app with the \"ESP_OTA_IMG_PENDING_VERIFY\" state set.\nThis state prevents the re-run of this app. After the first boot of the new app in the user code, the\nfunction should be called to confirm the operability of the app or vice versa about its non-operability.\nIf the app is working, then it is marked as valid. Otherwise, it is marked as not valid and rolls back to\nthe previous working app. A reboot is performed, and the app is booted before the software update.\nNote: If during the first boot a new app the power goes out or the WDT works, then roll back will happen.\nRollback is possible only between the apps with the same security versions.\n", 
                "id": "BOOTLOADER_APP_ROLLBACK_ENABLE", 
                "name": "BOOTLOADER_APP_ROLLBACK_ENABLE", 
                "range": null, 
                "title": "Enable app rollback support", 
                "type": "bool"
            }
        ], 
        "depends_on": null, 
        "id": "bootloader-config", 
        "title": "Bootloader config", 
        "type": "menu"
    }, 
    {
        "children": [
            {
                "children": [], 
                "depends_on": "SECURE_BOOT_ENABLED || SECURE_SIGNED_ON_BOOT_NO_SECURE_BOOT", 
                "help": null, 
                "id": "SECURE_SIGNED_ON_BOOT", 
                "name": "SECURE_SIGNED_ON_BOOT", 
                "range": null, 
                "title": null, 
                "type": "bool"
            }, 
            {
                "children": [], 
                "depends_on": "SECURE_BOOT_ENABLED || SECURE_SIGNED_ON_UPDATE_NO_SECURE_BOOT", 
                "help": null, 
                "id": "SECURE_SIGNED_ON_UPDATE", 
                "name": "SECURE_SIGNED_ON_UPDATE", 
                "range": null, 
                "title": null, 
                "type": "bool"
            }, 
            {
                "children": [], 
                "depends_on": "SECURE_SIGNED_ON_BOOT || SECURE_SIGNED_ON_UPDATE", 
                "help": null, 
                "id": "SECURE_SIGNED_APPS", 
                "name": "SECURE_SIGNED_APPS", 
                "range": null, 
                "title": null, 
                "type": "bool"
            }, 
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": "SECURE_SIGNED_APPS_NO_SECURE_BOOT", 
                        "help": "If this option is set, the bootloader will be compiled with code to verify that an app is signed before\nbooting it.\n\nIf hardware secure boot is enabled, this option is always enabled and cannot be disabled.\nIf hardware secure boot is not enabled, this option doesn't add significant security by itself so most\nusers will want to leave it disabled.\n", 
                        "id": "SECURE_SIGNED_ON_BOOT_NO_SECURE_BOOT", 
                        "name": "SECURE_SIGNED_ON_BOOT_NO_SECURE_BOOT", 
                        "range": null, 
                        "title": "Bootloader verifies app signatures", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "SECURE_SIGNED_APPS_NO_SECURE_BOOT", 
                        "help": "If this option is set, any OTA updated apps will have the signature verified before being considered valid.\n\nWhen enabled, the signature is automatically checked whenever the esp_ota_ops.h APIs are used for OTA\nupdates, or esp_image_format.h APIs are used to verify apps.\n\nIf hardware secure boot is enabled, this option is always enabled and cannot be disabled.\nIf hardware secure boot is not enabled, this option still adds significant security against network-based\nattackers by preventing spoofing of OTA updates.\n", 
                        "id": "SECURE_SIGNED_ON_UPDATE_NO_SECURE_BOOT", 
                        "name": "SECURE_SIGNED_ON_UPDATE_NO_SECURE_BOOT", 
                        "range": null, 
                        "title": "Verify app signature on update", 
                        "type": "bool"
                    }
                ], 
                "depends_on": "!SECURE_BOOT_ENABLED", 
                "help": "Require apps to be signed to verify their integrity.\n\nThis option uses the same app signature scheme as hardware secure boot, but unlike hardware secure boot it\ndoes not prevent the bootloader from being physically updated. This means that the device can be secured\nagainst remote network access, but not physical access. Compared to using hardware Secure Boot this option\nis much simpler to implement.\n", 
                "id": "SECURE_SIGNED_APPS_NO_SECURE_BOOT", 
                "name": "SECURE_SIGNED_APPS_NO_SECURE_BOOT", 
                "range": null, 
                "title": "Require signed app images", 
                "type": "bool"
            }, 
            {
                "children": [
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "<choice SECURE_BOOTLOADER_MODE>", 
                                "help": "On first boot, the bootloader will generate a key which is not readable externally or by software. A\ndigest is generated from the bootloader image itself. This digest will be verified on each subsequent\nboot.\n\nEnabling this option means that the bootloader cannot be changed after the first time it is booted.\n", 
                                "id": "SECURE_BOOTLOADER_ONE_TIME_FLASH", 
                                "name": "SECURE_BOOTLOADER_ONE_TIME_FLASH", 
                                "range": null, 
                                "title": "One-time flash", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice SECURE_BOOTLOADER_MODE>", 
                                "help": "Generate a reusable secure bootloader key, derived (via SHA-256) from the secure boot signing key.\n\nThis allows the secure bootloader to be re-flashed by anyone with access to the secure boot signing\nkey.\n\nThis option is less secure than one-time flash, because a leak of the digest key from one device\nallows reflashing of any device that uses it.\n", 
                                "id": "SECURE_BOOTLOADER_REFLASHABLE", 
                                "name": "SECURE_BOOTLOADER_REFLASHABLE", 
                                "range": null, 
                                "title": "Reflashable", 
                                "type": "bool"
                            }
                        ], 
                        "depends_on": "SECURE_BOOT_ENABLED", 
                        "help": null, 
                        "id": "security-features-enable-hardware-secure-boot-in-bootloader-read-docs-first--secure-bootloader-mode", 
                        "name": "SECURE_BOOTLOADER_MODE", 
                        "title": "Secure bootloader mode", 
                        "type": "choice"
                    }
                ], 
                "depends_on": null, 
                "help": "Build a bootloader which enables secure boot on first boot.\n\nOnce enabled, secure boot will not boot a modified bootloader. The bootloader will only load a partition\ntable or boot an app if the data has a verified digital signature. There are implications for reflashing\nupdated apps once secure boot is enabled.\n\nWhen enabling secure boot, JTAG and ROM BASIC Interpreter are permanently disabled by default.\n\nRefer to https://docs.espressif.com/projects/esp-idf/en/latest/security/secure-boot.html before enabling.\n", 
                "id": "SECURE_BOOT_ENABLED", 
                "name": "SECURE_BOOT_ENABLED", 
                "range": null, 
                "title": "Enable hardware secure boot in bootloader (READ DOCS FIRST)", 
                "type": "bool"
            }, 
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": "SECURE_BOOT_BUILD_SIGNED_BINARIES", 
                        "help": "Path to the key file used to sign app images.\n\nKey file is an ECDSA private key (NIST256p curve) in PEM format.\n\nPath is evaluated relative to the project directory.\n\nYou can generate a new signing key by running the following command:\nespsecure.py generate_signing_key secure_boot_signing_key.pem\n\nSee https://docs.espressif.com/projects/esp-idf/en/latest/security/secure-boot.html for details.\n", 
                        "id": "SECURE_BOOT_SIGNING_KEY", 
                        "name": "SECURE_BOOT_SIGNING_KEY", 
                        "range": null, 
                        "title": "Secure boot private signing key", 
                        "type": "string"
                    }
                ], 
                "depends_on": "SECURE_SIGNED_APPS", 
                "help": "Once secure boot or signed app requirement is enabled, app images are required to be signed.\n\nIf enabled (default), these binary files are signed as part of the build process. The file named in\n\"Secure boot private signing key\" will be used to sign the image.\n\nIf disabled, unsigned app/partition data will be built. They must be signed manually using espsecure.py\n(for example, on a remote signing server.)\n", 
                "id": "SECURE_BOOT_BUILD_SIGNED_BINARIES", 
                "name": "SECURE_BOOT_BUILD_SIGNED_BINARIES", 
                "range": null, 
                "title": "Sign binaries during build", 
                "type": "bool"
            }, 
            {
                "children": [], 
                "depends_on": "SECURE_SIGNED_APPS && !SECURE_BOOT_BUILD_SIGNED_BINARIES", 
                "help": "Path to a public key file used to verify signed images. This key is compiled into the bootloader and/or\napp, to verify app images.\n\nKey file is in raw binary format, and can be extracted from a\nPEM formatted private key using the espsecure.py\nextract_public_key command.\n\nRefer to https://docs.espressif.com/projects/esp-idf/en/latest/security/secure-boot.html before enabling.\n", 
                "id": "SECURE_BOOT_VERIFICATION_KEY", 
                "name": "SECURE_BOOT_VERIFICATION_KEY", 
                "range": null, 
                "title": "Secure boot public signature verification key", 
                "type": "string"
            }, 
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": "<choice SECURE_BOOTLOADER_KEY_ENCODING>", 
                        "help": null, 
                        "id": "SECURE_BOOTLOADER_KEY_ENCODING_256BIT", 
                        "name": "SECURE_BOOTLOADER_KEY_ENCODING_256BIT", 
                        "range": null, 
                        "title": "No encoding (256 bit key)", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice SECURE_BOOTLOADER_KEY_ENCODING>", 
                        "help": null, 
                        "id": "SECURE_BOOTLOADER_KEY_ENCODING_192BIT", 
                        "name": "SECURE_BOOTLOADER_KEY_ENCODING_192BIT", 
                        "range": null, 
                        "title": "3/4 encoding (192 bit key)", 
                        "type": "bool"
                    }
                ], 
                "depends_on": "SECURE_BOOTLOADER_REFLASHABLE", 
                "help": "In reflashable secure bootloader mode, a hardware key is derived from the signing key (with SHA-256) and\ncan be written to eFuse with espefuse.py.\n\nNormally this is a 256-bit key, but if 3/4 Coding Scheme is used on the device then the eFuse key is\ntruncated to 192 bits.\n\nThis configuration item doesn't change any firmware code, it only changes the size of key binary which is\ngenerated at build time.\n", 
                "id": "security-features-hardware-key-encoding", 
                "name": "SECURE_BOOTLOADER_KEY_ENCODING", 
                "title": "Hardware Key Encoding", 
                "type": "choice"
            }, 
            {
                "children": [], 
                "depends_on": "SECURE_BOOT_ENABLED", 
                "help": "You can disable some of the default protections offered by secure boot, in order to enable testing or a\ncustom combination of security features.\n\nOnly enable these options if you are very sure.\n\nRefer to https://docs.espressif.com/projects/esp-idf/en/latest/security/secure-boot.html before enabling.\n", 
                "id": "SECURE_BOOT_INSECURE", 
                "name": "SECURE_BOOT_INSECURE", 
                "range": null, 
                "title": "Allow potentially insecure options", 
                "type": "bool"
            }, 
            {
                "children": [
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "<choice SECURE_FLASH_ENCRYPTION_MODE>", 
                                "help": null, 
                                "id": "SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT", 
                                "name": "SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT", 
                                "range": null, 
                                "title": "Development(NOT SECURE)", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice SECURE_FLASH_ENCRYPTION_MODE>", 
                                "help": null, 
                                "id": "SECURE_FLASH_ENCRYPTION_MODE_RELEASE", 
                                "name": "SECURE_FLASH_ENCRYPTION_MODE_RELEASE", 
                                "range": null, 
                                "title": "Release", 
                                "type": "bool"
                            }
                        ], 
                        "depends_on": "SECURE_FLASH_ENC_ENABLED", 
                        "help": "By default Development mode is enabled which allows UART bootloader to perform flash encryption operations\n\nSelect Release mode only for production or manufacturing. Once enabled you can not reflash using UART\nbootloader\n\nRefer to https://docs.espressif.com/projects/esp-idf/en/latest/security/secure-boot.html and\nhttps://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html for details.\n", 
                        "id": "security-features-enable-flash-encryption-on-boot-read-docs-first--enable-usage-mode", 
                        "name": "SECURE_FLASH_ENCRYPTION_MODE", 
                        "title": "Enable usage mode", 
                        "type": "choice"
                    }
                ], 
                "depends_on": null, 
                "help": "If this option is set, flash contents will be encrypted by the bootloader on first boot.\n\nNote: After first boot, the system will be permanently encrypted. Re-flashing an encrypted\nsystem is complicated and not always possible.\n\nRead https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html\nbefore enabling.\n", 
                "id": "SECURE_FLASH_ENC_ENABLED", 
                "name": "SECURE_FLASH_ENC_ENABLED", 
                "range": null, 
                "title": "Enable flash encryption on boot (READ DOCS FIRST)", 
                "type": "bool"
            }, 
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": "SECURE_BOOT_INSECURE || SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT", 
                        "help": "By default, the BASIC ROM Console starts on reset if no valid bootloader is\nread from the flash.\n\nWhen either flash encryption or secure boot are enabled, the default is to\ndisable this BASIC fallback mode permanently via eFuse.\n\nIf this option is set, this eFuse is not burned and the BASIC ROM Console may\nremain accessible.  Only set this option in testing environments.\n", 
                        "id": "SECURE_BOOT_ALLOW_ROM_BASIC", 
                        "name": "SECURE_BOOT_ALLOW_ROM_BASIC", 
                        "range": null, 
                        "title": "Leave ROM BASIC Interpreter available on reset", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "SECURE_BOOT_INSECURE || SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT", 
                        "help": "If not set (default), the bootloader will permanently disable JTAG (across entire chip) on first boot\nwhen either secure boot or flash encryption is enabled.\n\nSetting this option leaves JTAG on for debugging, which negates all protections of flash encryption\nand some of the protections of secure boot.\n\nOnly set this option in testing environments.\n", 
                        "id": "SECURE_BOOT_ALLOW_JTAG", 
                        "name": "SECURE_BOOT_ALLOW_JTAG", 
                        "range": null, 
                        "title": "Allow JTAG Debugging", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "SECURE_BOOT_INSECURE", 
                        "help": "If not set (default), app partition size must be a multiple of 64KB. App images are padded to 64KB\nlength, and the bootloader checks any trailing bytes after the signature (before the next 64KB\nboundary) have not been written. This is because flash cache maps entire 64KB pages into the address\nspace. This prevents an attacker from appending unverified data after the app image in the flash,\ncausing it to be mapped into the address space.\n\nSetting this option allows the app partition length to be unaligned, and disables padding of the app\nimage to this length. It is generally not recommended to set this option, unless you have a legacy\npartitioning scheme which doesn't support 64KB aligned partition lengths.\n", 
                        "id": "SECURE_BOOT_ALLOW_SHORT_APP_PARTITION", 
                        "name": "SECURE_BOOT_ALLOW_SHORT_APP_PARTITION", 
                        "range": null, 
                        "title": "Allow app partition length not 64KB aligned", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT", 
                        "help": "If not set (default), the bootloader will permanently disable UART bootloader encryption access on\nfirst boot. If set, the UART bootloader will still be able to access hardware encryption.\n\nIt is recommended to only set this option in testing environments.\n", 
                        "id": "SECURE_FLASH_UART_BOOTLOADER_ALLOW_ENC", 
                        "name": "SECURE_FLASH_UART_BOOTLOADER_ALLOW_ENC", 
                        "range": null, 
                        "title": "Leave UART bootloader encryption enabled", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT", 
                        "help": "If not set (default), the bootloader will permanently disable UART bootloader decryption access on\nfirst boot. If set, the UART bootloader will still be able to access hardware decryption.\n\nOnly set this option in testing environments. Setting this option allows complete bypass of flash\nencryption.\n", 
                        "id": "SECURE_FLASH_UART_BOOTLOADER_ALLOW_DEC", 
                        "name": "SECURE_FLASH_UART_BOOTLOADER_ALLOW_DEC", 
                        "range": null, 
                        "title": "Leave UART bootloader decryption enabled", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT", 
                        "help": "If not set (default), the bootloader will permanently disable UART bootloader flash cache access on\nfirst boot. If set, the UART bootloader will still be able to access the flash cache.\n\nOnly set this option in testing environments.\n", 
                        "id": "SECURE_FLASH_UART_BOOTLOADER_ALLOW_CACHE", 
                        "name": "SECURE_FLASH_UART_BOOTLOADER_ALLOW_CACHE", 
                        "range": null, 
                        "title": "Leave UART bootloader flash cache enabled", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT", 
                        "help": "If not set (default), and flash encryption is not yet enabled in eFuses, the 2nd stage bootloader\nwill enable flash encryption: generate the flash encryption key and program eFuses.\nIf this option is set, and flash encryption is not yet enabled, the bootloader will error out and\nreboot.\nIf flash encryption is enabled in eFuses, this option does not change the bootloader behavior.\n\nOnly use this option in testing environments, to avoid accidentally enabling flash encryption on\nthe wrong device. The device needs to have flash encryption already enabled using espefuse.py.\n", 
                        "id": "SECURE_FLASH_REQUIRE_ALREADY_ENABLED", 
                        "name": "SECURE_FLASH_REQUIRE_ALREADY_ENABLED", 
                        "range": null, 
                        "title": "Require flash encryption to be already enabled", 
                        "type": "bool"
                    }
                ], 
                "depends_on": null, 
                "id": "security-features-potentially-insecure-options", 
                "title": "Potentially insecure options", 
                "type": "menu"
            }
        ], 
        "depends_on": null, 
        "id": "security-features", 
        "title": "Security features", 
        "type": "menu"
    }, 
    {
        "children": [
            {
                "children": [], 
                "depends_on": "!IDF_CMAKE", 
                "help": "The serial port that's connected to the ESP chip. This can be overridden by setting the ESPPORT\nenvironment variable.\n\nThis value is ignored when using the CMake-based build system or idf.py.\n", 
                "id": "ESPTOOLPY_PORT", 
                "name": "ESPTOOLPY_PORT", 
                "range": null, 
                "title": "Default serial port", 
                "type": "string"
            }, 
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_BAUD>", 
                        "help": null, 
                        "id": "ESPTOOLPY_BAUD_115200B", 
                        "name": "ESPTOOLPY_BAUD_115200B", 
                        "range": null, 
                        "title": "115200 baud", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_BAUD>", 
                        "help": null, 
                        "id": "ESPTOOLPY_BAUD_230400B", 
                        "name": "ESPTOOLPY_BAUD_230400B", 
                        "range": null, 
                        "title": "230400 baud", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_BAUD>", 
                        "help": null, 
                        "id": "ESPTOOLPY_BAUD_921600B", 
                        "name": "ESPTOOLPY_BAUD_921600B", 
                        "range": null, 
                        "title": "921600 baud", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_BAUD>", 
                        "help": null, 
                        "id": "ESPTOOLPY_BAUD_2MB", 
                        "name": "ESPTOOLPY_BAUD_2MB", 
                        "range": null, 
                        "title": "2Mbaud", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_BAUD>", 
                        "help": null, 
                        "id": "ESPTOOLPY_BAUD_OTHER", 
                        "name": "ESPTOOLPY_BAUD_OTHER", 
                        "range": null, 
                        "title": "Other baud rate", 
                        "type": "bool"
                    }
                ], 
                "depends_on": "!IDF_CMAKE", 
                "help": "Default baud rate to use while communicating with the ESP chip. Can be overridden by\nsetting the ESPBAUD variable.\n\nThis value is ignored when using the CMake-based build system or idf.py.\n", 
                "id": "serial-flasher-config-default-baud-rate", 
                "name": "ESPTOOLPY_BAUD", 
                "title": "Default baud rate", 
                "type": "choice"
            }, 
            {
                "children": [], 
                "depends_on": null, 
                "help": null, 
                "id": "ESPTOOLPY_BAUD_OTHER_VAL", 
                "name": "ESPTOOLPY_BAUD_OTHER_VAL", 
                "range": null, 
                "title": "Other baud rate value", 
                "type": "int"
            }, 
            {
                "children": [], 
                "depends_on": "!IDF_CMAKE", 
                "help": null, 
                "id": "ESPTOOLPY_BAUD", 
                "name": "ESPTOOLPY_BAUD", 
                "range": null, 
                "title": null, 
                "type": "int"
            }, 
            {
                "children": [], 
                "depends_on": "!IDF_CMAKE", 
                "help": "The flasher tool can send data compressed using zlib, letting the ROM on the ESP chip\ndecompress it on the fly before flashing it. For most payloads, this should result in a\nspeed increase.\n", 
                "id": "ESPTOOLPY_COMPRESSED", 
                "name": "ESPTOOLPY_COMPRESSED", 
                "range": null, 
                "title": "Use compressed upload", 
                "type": "bool"
            }, 
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_FLASHMODE>", 
                        "help": null, 
                        "id": "ESPTOOLPY_FLASHMODE_QIO", 
                        "name": "ESPTOOLPY_FLASHMODE_QIO", 
                        "range": null, 
                        "title": "QIO", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_FLASHMODE>", 
                        "help": null, 
                        "id": "ESPTOOLPY_FLASHMODE_QOUT", 
                        "name": "ESPTOOLPY_FLASHMODE_QOUT", 
                        "range": null, 
                        "title": "QOUT", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_FLASHMODE>", 
                        "help": null, 
                        "id": "ESPTOOLPY_FLASHMODE_DIO", 
                        "name": "ESPTOOLPY_FLASHMODE_DIO", 
                        "range": null, 
                        "title": "DIO", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_FLASHMODE>", 
                        "help": null, 
                        "id": "ESPTOOLPY_FLASHMODE_DOUT", 
                        "name": "ESPTOOLPY_FLASHMODE_DOUT", 
                        "range": null, 
                        "title": "DOUT", 
                        "type": "bool"
                    }
                ], 
                "depends_on": null, 
                "help": "Mode the flash chip is flashed in, as well as the default mode for the\nbinary to run in.\n", 
                "id": "serial-flasher-config-flash-spi-mode", 
                "name": "ESPTOOLPY_FLASHMODE", 
                "title": "Flash SPI mode", 
                "type": "choice"
            }, 
            {
                "children": [], 
                "depends_on": null, 
                "help": null, 
                "id": "ESPTOOLPY_FLASHMODE", 
                "name": "ESPTOOLPY_FLASHMODE", 
                "range": null, 
                "title": null, 
                "type": "string"
            }, 
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_FLASHFREQ>", 
                        "help": null, 
                        "id": "ESPTOOLPY_FLASHFREQ_80M", 
                        "name": "ESPTOOLPY_FLASHFREQ_80M", 
                        "range": null, 
                        "title": "80 MHz", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_FLASHFREQ>", 
                        "help": null, 
                        "id": "ESPTOOLPY_FLASHFREQ_40M", 
                        "name": "ESPTOOLPY_FLASHFREQ_40M", 
                        "range": null, 
                        "title": "40 MHz", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_FLASHFREQ>", 
                        "help": null, 
                        "id": "ESPTOOLPY_FLASHFREQ_26M", 
                        "name": "ESPTOOLPY_FLASHFREQ_26M", 
                        "range": null, 
                        "title": "26 MHz", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_FLASHFREQ>", 
                        "help": null, 
                        "id": "ESPTOOLPY_FLASHFREQ_20M", 
                        "name": "ESPTOOLPY_FLASHFREQ_20M", 
                        "range": null, 
                        "title": "20 MHz", 
                        "type": "bool"
                    }
                ], 
                "depends_on": null, 
                "help": "The SPI flash frequency to be used.\n", 
                "id": "serial-flasher-config-flash-spi-speed", 
                "name": "ESPTOOLPY_FLASHFREQ", 
                "title": "Flash SPI speed", 
                "type": "choice"
            }, 
            {
                "children": [], 
                "depends_on": null, 
                "help": null, 
                "id": "ESPTOOLPY_FLASHFREQ", 
                "name": "ESPTOOLPY_FLASHFREQ", 
                "range": null, 
                "title": null, 
                "type": "string"
            }, 
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_FLASHSIZE>", 
                        "help": null, 
                        "id": "ESPTOOLPY_FLASHSIZE_1MB", 
                        "name": "ESPTOOLPY_FLASHSIZE_1MB", 
                        "range": null, 
                        "title": "1 MB", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_FLASHSIZE>", 
                        "help": null, 
                        "id": "ESPTOOLPY_FLASHSIZE_2MB", 
                        "name": "ESPTOOLPY_FLASHSIZE_2MB", 
                        "range": null, 
                        "title": "2 MB", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_FLASHSIZE>", 
                        "help": null, 
                        "id": "ESPTOOLPY_FLASHSIZE_4MB", 
                        "name": "ESPTOOLPY_FLASHSIZE_4MB", 
                        "range": null, 
                        "title": "4 MB", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_FLASHSIZE>", 
                        "help": null, 
                        "id": "ESPTOOLPY_FLASHSIZE_8MB", 
                        "name": "ESPTOOLPY_FLASHSIZE_8MB", 
                        "range": null, 
                        "title": "8 MB", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_FLASHSIZE>", 
                        "help": null, 
                        "id": "ESPTOOLPY_FLASHSIZE_16MB", 
                        "name": "ESPTOOLPY_FLASHSIZE_16MB", 
                        "range": null, 
                        "title": "16 MB", 
                        "type": "bool"
                    }
                ], 
                "depends_on": null, 
                "help": "SPI flash size, in megabytes\n", 
                "id": "serial-flasher-config-flash-size", 
                "name": "ESPTOOLPY_FLASHSIZE", 
                "title": "Flash size", 
                "type": "choice"
            }, 
            {
                "children": [], 
                "depends_on": null, 
                "help": null, 
                "id": "ESPTOOLPY_FLASHSIZE", 
                "name": "ESPTOOLPY_FLASHSIZE", 
                "range": null, 
                "title": null, 
                "type": "string"
            }, 
            {
                "children": [], 
                "depends_on": null, 
                "help": "If this option is set, flashing the project will automatically detect\nthe flash size of the target chip and update the bootloader image\nbefore it is flashed.\n", 
                "id": "ESPTOOLPY_FLASHSIZE_DETECT", 
                "name": "ESPTOOLPY_FLASHSIZE_DETECT", 
                "range": null, 
                "title": "Detect flash size when flashing bootloader", 
                "type": "bool"
            }, 
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_BEFORE>", 
                        "help": null, 
                        "id": "ESPTOOLPY_BEFORE_RESET", 
                        "name": "ESPTOOLPY_BEFORE_RESET", 
                        "range": null, 
                        "title": "Reset to bootloader", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_BEFORE>", 
                        "help": null, 
                        "id": "ESPTOOLPY_BEFORE_NORESET", 
                        "name": "ESPTOOLPY_BEFORE_NORESET", 
                        "range": null, 
                        "title": "No reset", 
                        "type": "bool"
                    }
                ], 
                "depends_on": null, 
                "help": "Configure whether esptool.py should reset the ESP32 before flashing.\n\nAutomatic resetting depends on the RTS & DTR signals being\nwired from the serial port to the ESP32. Most USB development\nboards do this internally.\n", 
                "id": "serial-flasher-config-before-flashing", 
                "name": "ESPTOOLPY_BEFORE", 
                "title": "Before flashing", 
                "type": "choice"
            }, 
            {
                "children": [], 
                "depends_on": null, 
                "help": null, 
                "id": "ESPTOOLPY_BEFORE", 
                "name": "ESPTOOLPY_BEFORE", 
                "range": null, 
                "title": null, 
                "type": "string"
            }, 
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_AFTER>", 
                        "help": null, 
                        "id": "ESPTOOLPY_AFTER_RESET", 
                        "name": "ESPTOOLPY_AFTER_RESET", 
                        "range": null, 
                        "title": "Reset after flashing", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_AFTER>", 
                        "help": null, 
                        "id": "ESPTOOLPY_AFTER_NORESET", 
                        "name": "ESPTOOLPY_AFTER_NORESET", 
                        "range": null, 
                        "title": "Stay in bootloader", 
                        "type": "bool"
                    }
                ], 
                "depends_on": null, 
                "help": "Configure whether esptool.py should reset the ESP32 after flashing.\n\nAutomatic resetting depends on the RTS & DTR signals being\nwired from the serial port to the ESP32. Most USB development\nboards do this internally.\n", 
                "id": "serial-flasher-config-after-flashing", 
                "name": "ESPTOOLPY_AFTER", 
                "title": "After flashing", 
                "type": "choice"
            }, 
            {
                "children": [], 
                "depends_on": null, 
                "help": null, 
                "id": "ESPTOOLPY_AFTER", 
                "name": "ESPTOOLPY_AFTER", 
                "range": null, 
                "title": null, 
                "type": "string"
            }, 
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_MONITOR_BAUD>", 
                        "help": null, 
                        "id": "ESPTOOLPY_MONITOR_BAUD_9600B", 
                        "name": "ESPTOOLPY_MONITOR_BAUD_9600B", 
                        "range": null, 
                        "title": "9600 bps", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_MONITOR_BAUD>", 
                        "help": null, 
                        "id": "ESPTOOLPY_MONITOR_BAUD_57600B", 
                        "name": "ESPTOOLPY_MONITOR_BAUD_57600B", 
                        "range": null, 
                        "title": "57600 bps", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_MONITOR_BAUD>", 
                        "help": null, 
                        "id": "ESPTOOLPY_MONITOR_BAUD_115200B", 
                        "name": "ESPTOOLPY_MONITOR_BAUD_115200B", 
                        "range": null, 
                        "title": "115200 bps", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_MONITOR_BAUD>", 
                        "help": null, 
                        "id": "ESPTOOLPY_MONITOR_BAUD_230400B", 
                        "name": "ESPTOOLPY_MONITOR_BAUD_230400B", 
                        "range": null, 
                        "title": "230400 bps", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_MONITOR_BAUD>", 
                        "help": null, 
                        "id": "ESPTOOLPY_MONITOR_BAUD_921600B", 
                        "name": "ESPTOOLPY_MONITOR_BAUD_921600B", 
                        "range": null, 
                        "title": "921600 bps", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_MONITOR_BAUD>", 
                        "help": null, 
                        "id": "ESPTOOLPY_MONITOR_BAUD_2MB", 
                        "name": "ESPTOOLPY_MONITOR_BAUD_2MB", 
                        "range": null, 
                        "title": "2 Mbps", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice ESPTOOLPY_MONITOR_BAUD>", 
                        "help": null, 
                        "id": "ESPTOOLPY_MONITOR_BAUD_OTHER", 
                        "name": "ESPTOOLPY_MONITOR_BAUD_OTHER", 
                        "range": null, 
                        "title": "Custom baud rate", 
                        "type": "bool"
                    }
                ], 
                "depends_on": null, 
                "help": "Baud rate to use when running 'idf.py monitor' or 'make monitor'\nto view serial output from a running chip.\n\nCan override by setting the MONITORBAUD environment variable.\n", 
                "id": "serial-flasher-config--idf-py-monitor-baud-rate", 
                "name": "ESPTOOLPY_MONITOR_BAUD", 
                "title": "'idf.py monitor' baud rate", 
                "type": "choice"
            }, 
            {
                "children": [], 
                "depends_on": null, 
                "help": null, 
                "id": "ESPTOOLPY_MONITOR_BAUD_OTHER_VAL", 
                "name": "ESPTOOLPY_MONITOR_BAUD_OTHER_VAL", 
                "range": null, 
                "title": "Custom baud rate value", 
                "type": "int"
            }, 
            {
                "children": [], 
                "depends_on": null, 
                "help": null, 
                "id": "ESPTOOLPY_MONITOR_BAUD", 
                "name": "ESPTOOLPY_MONITOR_BAUD", 
                "range": null, 
                "title": null, 
                "type": "int"
            }
        ], 
        "depends_on": null, 
        "id": "serial-flasher-config", 
        "title": "Serial flasher config", 
        "type": "menu"
    }, 
    {
        "children": [
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": "<choice PARTITION_TABLE_TYPE>", 
                        "help": null, 
                        "id": "PARTITION_TABLE_SINGLE_APP", 
                        "name": "PARTITION_TABLE_SINGLE_APP", 
                        "range": null, 
                        "title": "Single factory app, no OTA", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice PARTITION_TABLE_TYPE>", 
                        "help": null, 
                        "id": "PARTITION_TABLE_TWO_OTA", 
                        "name": "PARTITION_TABLE_TWO_OTA", 
                        "range": null, 
                        "title": "Factory app, two OTA definitions", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice PARTITION_TABLE_TYPE>", 
                        "help": null, 
                        "id": "PARTITION_TABLE_CUSTOM", 
                        "name": "PARTITION_TABLE_CUSTOM", 
                        "range": null, 
                        "title": "Custom partition table CSV", 
                        "type": "bool"
                    }
                ], 
                "depends_on": null, 
                "help": "The partition table to flash to the ESP32. The partition table\ndetermines where apps, data and other resources are expected to\nbe found.\n\nThe predefined partition table CSV descriptions can be found\nin the components/partition_table directory. Otherwise it's\npossible to create a new custom partition CSV for your application.\n", 
                "id": "partition-table-partition-table", 
                "name": "PARTITION_TABLE_TYPE", 
                "title": "Partition Table", 
                "type": "choice"
            }, 
            {
                "children": [], 
                "depends_on": null, 
                "help": "Name of the custom partition CSV filename. This path is evaluated\nrelative to the project root directory.\n", 
                "id": "PARTITION_TABLE_CUSTOM_FILENAME", 
                "name": "PARTITION_TABLE_CUSTOM_FILENAME", 
                "range": null, 
                "title": "Custom partition CSV file", 
                "type": "string"
            }, 
            {
                "children": [], 
                "depends_on": null, 
                "help": null, 
                "id": "PARTITION_TABLE_FILENAME", 
                "name": "PARTITION_TABLE_FILENAME", 
                "range": null, 
                "title": null, 
                "type": "string"
            }, 
            {
                "children": [], 
                "depends_on": null, 
                "help": "The address of partition table (by default 0x8000).\nAllows you to move the partition table, it gives more space for the bootloader.\nNote that the bootloader and app will both need to be compiled with the same PARTITION_TABLE_OFFSET value.\n\nThis number should be a multiple of 0x1000.\n\nNote that partition offsets in the partition table CSV file may need to be changed if this value is set to\na higher value. To have each partition offset adapt to the configured partition table offset, leave all\npartition offsets blank in the CSV file.\n", 
                "id": "PARTITION_TABLE_OFFSET", 
                "name": "PARTITION_TABLE_OFFSET", 
                "range": null, 
                "title": "Offset of partition table", 
                "type": "hex"
            }, 
            {
                "children": [], 
                "depends_on": null, 
                "help": "Generate an MD5 checksum for the partition table for protecting the\nintegrity of the table. The generation should be turned off for legacy\nbootloaders which cannot recognize the MD5 checksum in the partition\ntable.\n", 
                "id": "PARTITION_TABLE_MD5", 
                "name": "PARTITION_TABLE_MD5", 
                "range": null, 
                "title": "Generate an MD5 checksum for the partition table", 
                "type": "bool"
            }
        ], 
        "depends_on": null, 
        "id": "partition-table", 
        "title": "Partition Table", 
        "type": "menu"
    }, 
    {
        "children": [
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": "<choice COMPILER_OPTIMIZATION>", 
                        "help": null, 
                        "id": "COMPILER_OPTIMIZATION_LEVEL_DEBUG", 
                        "name": "COMPILER_OPTIMIZATION_LEVEL_DEBUG", 
                        "range": null, 
                        "title": "Debug (-Og)", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice COMPILER_OPTIMIZATION>", 
                        "help": null, 
                        "id": "COMPILER_OPTIMIZATION_LEVEL_RELEASE", 
                        "name": "COMPILER_OPTIMIZATION_LEVEL_RELEASE", 
                        "range": null, 
                        "title": "Release (-Os)", 
                        "type": "bool"
                    }
                ], 
                "depends_on": null, 
                "help": "This option sets compiler optimization level (gcc -O argument).\n\n- for \"Release\" setting, -Os flag is added to CFLAGS.\n- for \"Debug\" setting, -Og flag is added to CFLAGS.\n\n\"Release\" with -Os produces smaller & faster compiled code but it\nmay be harder to correlated code addresses to source files when debugging.\n\nTo add custom optimization settings, set CFLAGS and/or CPPFLAGS\nin project makefile, before including $(IDF_PATH)/make/project.mk. Note that\ncustom optimization levels may be unsupported.\n", 
                "id": "compiler-options-optimization-level", 
                "name": "COMPILER_OPTIMIZATION", 
                "title": "Optimization Level", 
                "type": "choice"
            }, 
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": "<choice COMPILER_OPTIMIZATION_ASSERTION_LEVEL>", 
                        "help": "Enable assertions. Assertion content and line number will be printed on failure.\n", 
                        "id": "COMPILER_OPTIMIZATION_ASSERTIONS_ENABLE", 
                        "name": "COMPILER_OPTIMIZATION_ASSERTIONS_ENABLE", 
                        "range": null, 
                        "title": "Enabled", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice COMPILER_OPTIMIZATION_ASSERTION_LEVEL>", 
                        "help": "Enable silent assertions. Failed assertions will abort(), user needs to\nuse the aborting address to find the line number with the failed assertion.\n", 
                        "id": "COMPILER_OPTIMIZATION_ASSERTIONS_SILENT", 
                        "name": "COMPILER_OPTIMIZATION_ASSERTIONS_SILENT", 
                        "range": null, 
                        "title": "Silent (saves code size)", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice COMPILER_OPTIMIZATION_ASSERTION_LEVEL>", 
                        "help": "If assertions are disabled, -DNDEBUG is added to CPPFLAGS.\n", 
                        "id": "COMPILER_OPTIMIZATION_ASSERTIONS_DISABLE", 
                        "name": "COMPILER_OPTIMIZATION_ASSERTIONS_DISABLE", 
                        "range": null, 
                        "title": "Disabled (sets -DNDEBUG)", 
                        "type": "bool"
                    }
                ], 
                "depends_on": null, 
                "help": "Assertions can be:\n\n- Enabled. Failure will print verbose assertion details. This is the default.\n\n- Set to \"silent\" to save code size (failed assertions will abort() but user\n  needs to use the aborting address to find the line number with the failed assertion.)\n\n- Disabled entirely (not recommended for most configurations.) -DNDEBUG is added\n  to CPPFLAGS in this case.\n", 
                "id": "compiler-options-assertion-level", 
                "name": "COMPILER_OPTIMIZATION_ASSERTION_LEVEL", 
                "title": "Assertion level", 
                "type": "choice"
            }, 
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": "COMPILER_CXX_EXCEPTIONS", 
                        "help": "Size (in bytes) of the emergency memory pool for C++ exceptions. This pool will be used to allocate\nmemory for thrown exceptions when there is not enough memory on the heap.\n", 
                        "id": "COMPILER_CXX_EXCEPTIONS_EMG_POOL_SIZE", 
                        "name": "COMPILER_CXX_EXCEPTIONS_EMG_POOL_SIZE", 
                        "range": null, 
                        "title": "Emergency Pool Size", 
                        "type": "int"
                    }
                ], 
                "depends_on": null, 
                "help": "Enabling this option compiles all IDF C++ files with exception support enabled.\n\nDisabling this option disables C++ exception support in all compiled files, and any libstdc++ code\nwhich throws an exception will abort instead.\n\nEnabling this option currently adds an additional ~500 bytes of heap overhead\nwhen an exception is thrown in user code for the first time.\n", 
                "id": "COMPILER_CXX_EXCEPTIONS", 
                "is_menuconfig": true, 
                "name": "COMPILER_CXX_EXCEPTIONS", 
                "range": null, 
                "title": "Enable C++ exceptions", 
                "type": "menu"
            }, 
            {
                "children": [], 
                "depends_on": null, 
                "help": "Enabling this option compiles all C++ files with RTTI support enabled.\nThis increases binary size (typically by tens of kB) but allows using\ndynamic_cast conversion and typeid operator.\n", 
                "id": "COMPILER_CXX_RTTI", 
                "name": "COMPILER_CXX_RTTI", 
                "range": null, 
                "title": null, 
                "type": "bool"
            }, 
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": "<choice COMPILER_STACK_CHECK_MODE>", 
                        "help": null, 
                        "id": "COMPILER_STACK_CHECK_MODE_NONE", 
                        "name": "COMPILER_STACK_CHECK_MODE_NONE", 
                        "range": null, 
                        "title": "None", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice COMPILER_STACK_CHECK_MODE>", 
                        "help": null, 
                        "id": "COMPILER_STACK_CHECK_MODE_NORM", 
                        "name": "COMPILER_STACK_CHECK_MODE_NORM", 
                        "range": null, 
                        "title": "Normal", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice COMPILER_STACK_CHECK_MODE>", 
                        "help": null, 
                        "id": "COMPILER_STACK_CHECK_MODE_STRONG", 
                        "name": "COMPILER_STACK_CHECK_MODE_STRONG", 
                        "range": null, 
                        "title": "Strong", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "<choice COMPILER_STACK_CHECK_MODE>", 
                        "help": null, 
                        "id": "COMPILER_STACK_CHECK_MODE_ALL", 
                        "name": "COMPILER_STACK_CHECK_MODE_ALL", 
                        "range": null, 
                        "title": "Overall", 
                        "type": "bool"
                    }
                ], 
                "depends_on": null, 
                "help": "Stack smashing protection mode. Emit extra code to check for buffer overflows, such as stack\nsmashing attacks. This is done by adding a guard variable to functions with vulnerable objects.\nThe guards are initialized when a function is entered and then checked when the function exits.\nIf a guard check fails, program is halted. Protection has the following modes:\n\n- In NORMAL mode (GCC flag: -fstack-protector) only functions that call alloca, and functions with\n  buffers larger than 8 bytes are protected.\n\n- STRONG mode (GCC flag: -fstack-protector-strong) is like NORMAL, but includes additional functions\n  to be protected -- those that have local array definitions, or have references to local frame\n  addresses.\n\n- In OVERALL mode (GCC flag: -fstack-protector-all) all functions are protected.\n\nModes have the following impact on code performance and coverage:\n\n- performance: NORMAL > STRONG > OVERALL\n\n- coverage: NORMAL < STRONG < OVERALL\n", 
                "id": "compiler-options-stack-smashing-protection-mode", 
                "name": "COMPILER_STACK_CHECK_MODE", 
                "title": "Stack smashing protection mode", 
                "type": "choice"
            }, 
            {
                "children": [], 
                "depends_on": null, 
                "help": "Stack smashing protection.\n", 
                "id": "COMPILER_STACK_CHECK", 
                "name": "COMPILER_STACK_CHECK", 
                "range": null, 
                "title": null, 
                "type": "bool"
            }, 
            {
                "children": [], 
                "depends_on": null, 
                "help": "Adds -Wwrite-strings flag for the C/C++ compilers.\n\nFor C, this gives string constants the type ``const char[]`` so that\ncopying the address of one into a non-const ``char *`` pointer\nproduces a warning. This warning helps to find at compile time code\nthat tries to write into a string constant.\n\nFor C++, this warns about the deprecated conversion from string\nliterals to ``char *``.\n", 
                "id": "COMPILER_WARN_WRITE_STRINGS", 
                "name": "COMPILER_WARN_WRITE_STRINGS", 
                "range": null, 
                "title": "Enable -Wwrite-strings warning flag", 
                "type": "bool"
            }, 
            {
                "children": [], 
                "depends_on": null, 
                "help": "Enable this option if using GCC 6 or newer, and wanting to disable warnings which don't appear with\nGCC 5.\n", 
                "id": "COMPILER_DISABLE_GCC8_WARNINGS", 
                "name": "COMPILER_DISABLE_GCC8_WARNINGS", 
                "range": null, 
                "title": "Disable new warnings introduced in GCC 6 - 8", 
                "type": "bool"
            }
        ], 
        "depends_on": null, 
        "id": "compiler-options", 
        "title": "Compiler options", 
        "type": "menu"
    }, 
    {
        "children": [
            {
                "children": [
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "EFUSE_CUSTOM_TABLE", 
                                "help": "Name of the custom eFuse CSV filename. This path is evaluated\nrelative to the project root directory.\n", 
                                "id": "EFUSE_CUSTOM_TABLE_FILENAME", 
                                "name": "EFUSE_CUSTOM_TABLE_FILENAME", 
                                "range": null, 
                                "title": "Custom eFuse CSV file", 
                                "type": "string"
                            }
                        ], 
                        "depends_on": null, 
                        "help": "Allows to generate a structure for eFuse from the CSV file.\n", 
                        "id": "EFUSE_CUSTOM_TABLE", 
                        "name": "EFUSE_CUSTOM_TABLE", 
                        "range": null, 
                        "title": "Use custom eFuse table", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": "All read and writes operations are redirected to RAM instead of eFuse registers.\nIf this option is set, all permanent changes (via eFuse) are disabled.\nLog output will state changes which would be applied, but they will not be.\n", 
                        "id": "EFUSE_VIRTUAL", 
                        "name": "EFUSE_VIRTUAL", 
                        "range": null, 
                        "title": "Simulate eFuse operations in RAM", 
                        "type": "bool"
                    }, 
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "<choice EFUSE_CODE_SCHEME_SELECTOR>", 
                                "help": null, 
                                "id": "EFUSE_CODE_SCHEME_COMPAT_NONE", 
                                "name": "EFUSE_CODE_SCHEME_COMPAT_NONE", 
                                "range": null, 
                                "title": "None Only", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice EFUSE_CODE_SCHEME_SELECTOR>", 
                                "help": null, 
                                "id": "EFUSE_CODE_SCHEME_COMPAT_3_4", 
                                "name": "EFUSE_CODE_SCHEME_COMPAT_3_4", 
                                "range": null, 
                                "title": "3/4 and None", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice EFUSE_CODE_SCHEME_SELECTOR>", 
                                "help": null, 
                                "id": "EFUSE_CODE_SCHEME_COMPAT_REPEAT", 
                                "name": "EFUSE_CODE_SCHEME_COMPAT_REPEAT", 
                                "range": null, 
                                "title": "Repeat, 3/4 and None (common table does not support it)", 
                                "type": "bool"
                            }
                        ], 
                        "depends_on": null, 
                        "help": "Selector eFuse code scheme.\n", 
                        "id": "component-config-efuse-bit-manager-coding-scheme-compatibility", 
                        "name": "EFUSE_CODE_SCHEME_SELECTOR", 
                        "title": "Coding Scheme Compatibility", 
                        "type": "choice"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": null, 
                        "id": "EFUSE_MAX_BLK_LEN", 
                        "name": "EFUSE_MAX_BLK_LEN", 
                        "range": null, 
                        "title": null, 
                        "type": "int"
                    }
                ], 
                "depends_on": null, 
                "id": "component-config-efuse-bit-manager", 
                "title": "eFuse Bit Manager", 
                "type": "menu"
            }, 
            {
                "children": [
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_REV_MIN>", 
                                "help": null, 
                                "id": "ESP32_REV_MIN_0", 
                                "name": "ESP32_REV_MIN_0", 
                                "range": null, 
                                "title": "Rev 0", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_REV_MIN>", 
                                "help": null, 
                                "id": "ESP32_REV_MIN_1", 
                                "name": "ESP32_REV_MIN_1", 
                                "range": null, 
                                "title": "Rev 1", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_REV_MIN>", 
                                "help": null, 
                                "id": "ESP32_REV_MIN_2", 
                                "name": "ESP32_REV_MIN_2", 
                                "range": null, 
                                "title": "Rev 2", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_REV_MIN>", 
                                "help": null, 
                                "id": "ESP32_REV_MIN_3", 
                                "name": "ESP32_REV_MIN_3", 
                                "range": null, 
                                "title": "Rev 3", 
                                "type": "bool"
                            }
                        ], 
                        "depends_on": null, 
                        "help": "Minimum revision that ESP-IDF would support.\nESP-IDF performs different strategy on different esp32 revision.\n", 
                        "id": "component-config-esp32-specific-minimum-supported-esp32-revision", 
                        "name": "ESP32_REV_MIN", 
                        "title": "Minimum Supported ESP32 Revision", 
                        "type": "choice"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": null, 
                        "id": "ESP32_REV_MIN", 
                        "name": "ESP32_REV_MIN", 
                        "range": null, 
                        "title": null, 
                        "type": "int"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": null, 
                        "id": "ESP32_DPORT_WORKAROUND", 
                        "name": "ESP32_DPORT_WORKAROUND", 
                        "range": null, 
                        "title": null, 
                        "type": "bool"
                    }, 
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_DEFAULT_CPU_FREQ_MHZ>", 
                                "help": null, 
                                "id": "ESP32_DEFAULT_CPU_FREQ_80", 
                                "name": "ESP32_DEFAULT_CPU_FREQ_80", 
                                "range": null, 
                                "title": "80 MHz", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_DEFAULT_CPU_FREQ_MHZ>", 
                                "help": null, 
                                "id": "ESP32_DEFAULT_CPU_FREQ_160", 
                                "name": "ESP32_DEFAULT_CPU_FREQ_160", 
                                "range": null, 
                                "title": "160 MHz", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_DEFAULT_CPU_FREQ_MHZ>", 
                                "help": null, 
                                "id": "ESP32_DEFAULT_CPU_FREQ_240", 
                                "name": "ESP32_DEFAULT_CPU_FREQ_240", 
                                "range": null, 
                                "title": "240 MHz", 
                                "type": "bool"
                            }
                        ], 
                        "depends_on": null, 
                        "help": "CPU frequency to be set on application startup.\n", 
                        "id": "component-config-esp32-specific-cpu-frequency", 
                        "name": "ESP32_DEFAULT_CPU_FREQ_MHZ", 
                        "title": "CPU frequency", 
                        "type": "choice"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": null, 
                        "id": "ESP32_DEFAULT_CPU_FREQ_MHZ", 
                        "name": "ESP32_DEFAULT_CPU_FREQ_MHZ", 
                        "range": null, 
                        "title": null, 
                        "type": "int"
                    }, 
                    {
                        "children": [
                            {
                                "children": [
                                    {
                                        "children": [
                                            {
                                                "children": [], 
                                                "depends_on": "SPIRAM_BOOT_INIT && !SPIRAM_ALLOW_BSS_SEG_EXTERNAL_MEMORY && ESP32_SPIRAM_SUPPORT", 
                                                "help": "Normally, if psram initialization is enabled during compile time but not found at runtime, it\nis seen as an error making the ESP32 panic. If this is enabled, the ESP32 will keep on\nrunning but will not add the (non-existing) RAM to any allocator.\n", 
                                                "id": "SPIRAM_IGNORE_NOTFOUND", 
                                                "name": "SPIRAM_IGNORE_NOTFOUND", 
                                                "range": null, 
                                                "title": "Ignore PSRAM when not found", 
                                                "type": "bool"
                                            }
                                        ], 
                                        "depends_on": "ESP32_SPIRAM_SUPPORT", 
                                        "help": "If this is enabled, the SPI RAM will be enabled during initial boot. Unless you\nhave specific requirements, you'll want to leave this enabled so memory allocated\nduring boot-up can also be placed in SPI RAM.\n", 
                                        "id": "SPIRAM_BOOT_INIT", 
                                        "name": "SPIRAM_BOOT_INIT", 
                                        "range": null, 
                                        "title": "Initialize SPI RAM when booting the ESP32", 
                                        "type": "bool"
                                    }, 
                                    {
                                        "children": [
                                            {
                                                "children": [], 
                                                "depends_on": "<choice SPIRAM_USE>", 
                                                "help": null, 
                                                "id": "SPIRAM_USE_MEMMAP", 
                                                "name": "SPIRAM_USE_MEMMAP", 
                                                "range": null, 
                                                "title": "Integrate RAM into ESP32 memory map", 
                                                "type": "bool"
                                            }, 
                                            {
                                                "children": [], 
                                                "depends_on": "<choice SPIRAM_USE>", 
                                                "help": null, 
                                                "id": "SPIRAM_USE_CAPS_ALLOC", 
                                                "name": "SPIRAM_USE_CAPS_ALLOC", 
                                                "range": null, 
                                                "title": "Make RAM allocatable using heap_caps_malloc(..., MALLOC_CAP_SPIRAM)", 
                                                "type": "bool"
                                            }, 
                                            {
                                                "children": [], 
                                                "depends_on": "<choice SPIRAM_USE>", 
                                                "help": null, 
                                                "id": "SPIRAM_USE_MALLOC", 
                                                "name": "SPIRAM_USE_MALLOC", 
                                                "range": null, 
                                                "title": "Make RAM allocatable using malloc() as well", 
                                                "type": "bool"
                                            }
                                        ], 
                                        "depends_on": "ESP32_SPIRAM_SUPPORT", 
                                        "help": "The SPI RAM can be accessed in multiple methods: by just having it available as an unmanaged\nmemory region in the ESP32 memory map, by integrating it in the ESP32s heap as 'special' memory\nneeding heap_caps_malloc to allocate, or by fully integrating it making malloc() also able to\nreturn SPI RAM pointers.\n", 
                                        "id": "component-config-esp32-specific-support-for-external-spi-connected-ram-spi-ram-config-spi-ram-access-method", 
                                        "name": "SPIRAM_USE", 
                                        "title": "SPI RAM access method", 
                                        "type": "choice"
                                    }, 
                                    {
                                        "children": [
                                            {
                                                "children": [], 
                                                "depends_on": "<choice SPIRAM_TYPE>", 
                                                "help": null, 
                                                "id": "SPIRAM_TYPE_AUTO", 
                                                "name": "SPIRAM_TYPE_AUTO", 
                                                "range": null, 
                                                "title": "Auto-detect", 
                                                "type": "bool"
                                            }, 
                                            {
                                                "children": [], 
                                                "depends_on": "<choice SPIRAM_TYPE>", 
                                                "help": null, 
                                                "id": "SPIRAM_TYPE_ESPPSRAM32", 
                                                "name": "SPIRAM_TYPE_ESPPSRAM32", 
                                                "range": null, 
                                                "title": "ESP-PSRAM32 or IS25WP032", 
                                                "type": "bool"
                                            }, 
                                            {
                                                "children": [], 
                                                "depends_on": "<choice SPIRAM_TYPE>", 
                                                "help": null, 
                                                "id": "SPIRAM_TYPE_ESPPSRAM64", 
                                                "name": "SPIRAM_TYPE_ESPPSRAM64", 
                                                "range": null, 
                                                "title": "ESP-PSRAM64 or LY68L6400", 
                                                "type": "bool"
                                            }
                                        ], 
                                        "depends_on": "ESP32_SPIRAM_SUPPORT", 
                                        "help": null, 
                                        "id": "component-config-esp32-specific-support-for-external-spi-connected-ram-spi-ram-config-type-of-spi-ram-chip-in-use", 
                                        "name": "SPIRAM_TYPE", 
                                        "title": "Type of SPI RAM chip in use", 
                                        "type": "choice"
                                    }, 
                                    {
                                        "children": [], 
                                        "depends_on": "ESP32_SPIRAM_SUPPORT", 
                                        "help": null, 
                                        "id": "SPIRAM_SIZE", 
                                        "name": "SPIRAM_SIZE", 
                                        "range": null, 
                                        "title": null, 
                                        "type": "int"
                                    }, 
                                    {
                                        "children": [
                                            {
                                                "children": [], 
                                                "depends_on": "<choice SPIRAM_SPEED>", 
                                                "help": null, 
                                                "id": "SPIRAM_SPEED_40M", 
                                                "name": "SPIRAM_SPEED_40M", 
                                                "range": null, 
                                                "title": "40MHz clock speed", 
                                                "type": "bool"
                                            }, 
                                            {
                                                "children": [], 
                                                "depends_on": "ESPTOOLPY_FLASHFREQ_80M && <choice SPIRAM_SPEED>", 
                                                "help": null, 
                                                "id": "SPIRAM_SPEED_80M", 
                                                "name": "SPIRAM_SPEED_80M", 
                                                "range": null, 
                                                "title": "80MHz clock speed", 
                                                "type": "bool"
                                            }
                                        ], 
                                        "depends_on": "ESP32_SPIRAM_SUPPORT", 
                                        "help": "Select the speed for the SPI RAM chip.\nIf SPI RAM is enabled, we only support three combinations of SPI speed mode we supported now:\n\n1. Flash SPI running at 40Mhz and RAM SPI running at 40Mhz\n2. Flash SPI running at 80Mhz and RAM SPI running at 40Mhz\n3. Flash SPI running at 80Mhz and RAM SPI running at 80Mhz\n\nNote: If the third mode(80Mhz+80Mhz) is enabled for SPI RAM of type 32MBit, one of the HSPI/VSPI host\nwill be occupied by the system. Which SPI host to use can be selected by the config item\nSPIRAM_OCCUPY_SPI_HOST. Application code should never touch HSPI/VSPI hardware in this case. The\noption to select 80MHz will only be visible if the flash SPI speed is also 80MHz.\n(ESPTOOLPY_FLASHFREQ_80M is true)\n", 
                                        "id": "component-config-esp32-specific-support-for-external-spi-connected-ram-spi-ram-config-set-ram-clock-speed", 
                                        "name": "SPIRAM_SPEED", 
                                        "title": "Set RAM clock speed", 
                                        "type": "choice"
                                    }, 
                                    {
                                        "children": [], 
                                        "depends_on": "SPIRAM_BOOT_INIT && ESP32_SPIRAM_SUPPORT", 
                                        "help": "Runs a rudimentary memory test on initialization. Aborts when memory test fails. Disable this for\nslightly faster startop.\n", 
                                        "id": "SPIRAM_MEMTEST", 
                                        "name": "SPIRAM_MEMTEST", 
                                        "range": null, 
                                        "title": "Run memory test on SPI RAM initialization", 
                                        "type": "bool"
                                    }, 
                                    {
                                        "children": [], 
                                        "depends_on": "(SPIRAM_USE_MEMMAP || SPIRAM_USE_CAPS_ALLOC || SPIRAM_USE_MALLOC) && ESP32_REV_MIN < 3 && ESP32_SPIRAM_SUPPORT", 
                                        "help": "Revision 1 of the ESP32 has a bug that can cause a write to PSRAM not to take place in some situations\nwhen the cache line needs to be fetched from external RAM and an interrupt occurs. This enables a\nfix in the compiler (-mfix-esp32-psram-cache-issue) that makes sure the specific code that is\nvulnerable to this will not be emitted.\n\nThis will also not use any bits of newlib that are located in ROM, opting for a version that is\ncompiled with the workaround and located in flash instead.\n\nThe workaround is not required for ESP32 revision 3 and above.\n", 
                                        "id": "SPIRAM_CACHE_WORKAROUND", 
                                        "name": "SPIRAM_CACHE_WORKAROUND", 
                                        "range": null, 
                                        "title": "Enable workaround for bug in SPI RAM cache for Rev1 ESP32s", 
                                        "type": "bool"
                                    }, 
                                    {
                                        "children": [
                                            {
                                                "children": [], 
                                                "depends_on": "SPIRAM_BANKSWITCH_ENABLE && ESP32_SPIRAM_SUPPORT", 
                                                "help": "Select the amount of banks reserved for bank switching. Note that the amount of RAM allocatable with\nmalloc/esp_heap_alloc_caps will decrease by 32K for each page reserved here.\n\nNote that this reservation is only actually done if your program actually uses the himem API. Without\nany himem calls, the reservation is not done and the original amount of memory will be available\nto malloc/esp_heap_alloc_caps.\n", 
                                                "id": "SPIRAM_BANKSWITCH_RESERVE", 
                                                "name": "SPIRAM_BANKSWITCH_RESERVE", 
                                                "range": null, 
                                                "title": "Amount of 32K pages to reserve for bank switching", 
                                                "type": "int"
                                            }
                                        ], 
                                        "depends_on": "(SPIRAM_USE_MEMMAP || SPIRAM_USE_CAPS_ALLOC || SPIRAM_USE_MALLOC) && ESP32_SPIRAM_SUPPORT", 
                                        "help": "The ESP32 only supports 4MiB of external RAM in its address space. The hardware does support larger\nmemories, but these have to be bank-switched in and out of this address space. Enabling this allows you\nto reserve some MMU pages for this, which allows the use of the esp_himem api to manage these banks.\n\n#Note that this is limited to 62 banks, as esp_spiram_writeback_cache needs some kind of mapping of\n#some banks below that mark to work. We cannot at this moment guarantee this to exist when himem is\n#enabled.\n\nIf spiram 2T mode is enabled, the size of 64Mbit psram will be changed as 32Mbit, so himem will be\nunusable.\n", 
                                        "id": "SPIRAM_BANKSWITCH_ENABLE", 
                                        "name": "SPIRAM_BANKSWITCH_ENABLE", 
                                        "range": null, 
                                        "title": "Enable bank switching for >4MiB external RAM", 
                                        "type": "bool"
                                    }, 
                                    {
                                        "children": [], 
                                        "depends_on": "SPIRAM_USE_MALLOC && ESP32_SPIRAM_SUPPORT", 
                                        "help": "If malloc() is capable of also allocating SPI-connected ram, its allocation strategy will prefer to\nallocate chunks less than this size in internal memory, while allocations larger than this will be\ndone from external RAM. If allocation from the preferred region fails, an attempt is made to allocate\nfrom the non-preferred region instead, so malloc() will not suddenly fail when either internal or\nexternal memory is full.\n", 
                                        "id": "SPIRAM_MALLOC_ALWAYSINTERNAL", 
                                        "name": "SPIRAM_MALLOC_ALWAYSINTERNAL", 
                                        "range": null, 
                                        "title": "Maximum malloc() size, in bytes, to always put in internal memory", 
                                        "type": "int"
                                    }, 
                                    {
                                        "children": [], 
                                        "depends_on": "(SPIRAM_USE_CAPS_ALLOC || SPIRAM_USE_MALLOC) && ESP32_SPIRAM_SUPPORT", 
                                        "help": "Try to allocate memories of WiFi and LWIP in SPIRAM firstly. If failed, try to allocate internal\nmemory then.\n", 
                                        "id": "SPIRAM_TRY_ALLOCATE_WIFI_LWIP", 
                                        "name": "SPIRAM_TRY_ALLOCATE_WIFI_LWIP", 
                                        "range": null, 
                                        "title": "Try to allocate memories of WiFi and LWIP in SPIRAM firstly. If failed, allocate internal memory", 
                                        "type": "bool"
                                    }, 
                                    {
                                        "children": [], 
                                        "depends_on": "SPIRAM_USE_MALLOC && ESP32_SPIRAM_SUPPORT", 
                                        "help": "Because the external/internal RAM allocation strategy is not always perfect, it sometimes may happen\nthat the internal memory is entirely filled up. This causes allocations that are specifically done in\ninternal memory, for example the stack for new tasks or memory to service DMA or have memory that's\nalso available when SPI cache is down, to fail. This option reserves a pool specifically for requests\nlike that; the memory in this pool is not given out when a normal malloc() is called.\n\nSet this to 0 to disable this feature.\n\nNote that because FreeRTOS stacks are forced to internal memory, they will also use this memory pool;\nbe sure to keep this in mind when adjusting this value.\n\nNote also that the DMA reserved pool may not be one single contiguous memory region, depending on the\nconfigured size and the static memory usage of the app.\n", 
                                        "id": "SPIRAM_MALLOC_RESERVE_INTERNAL", 
                                        "name": "SPIRAM_MALLOC_RESERVE_INTERNAL", 
                                        "range": null, 
                                        "title": "Reserve this amount of bytes for data that specifically needs to be in DMA or internal memory", 
                                        "type": "int"
                                    }, 
                                    {
                                        "children": [], 
                                        "depends_on": "SPIRAM_USE_MALLOC && ESP32_SPIRAM_SUPPORT", 
                                        "help": "Because some bits of the ESP32 code environment cannot be recompiled with the cache workaround,\nnormally tasks cannot be safely run with their stack residing in external memory; for this reason\nxTaskCreate and friends always allocate stack in internal memory and xTaskCreateStatic will check if\nthe memory passed to it is in internal memory. If you have a task that needs a large amount of stack\nand does not call on ROM code in any way (no direct calls, but also no Bluetooth/WiFi), you can try to\ndisable this and use xTaskCreateStatic to create the tasks stack in external memory.\n", 
                                        "id": "SPIRAM_ALLOW_STACK_EXTERNAL_MEMORY", 
                                        "name": "SPIRAM_ALLOW_STACK_EXTERNAL_MEMORY", 
                                        "range": null, 
                                        "title": "Allow external memory as an argument to xTaskCreateStatic", 
                                        "type": "bool"
                                    }, 
                                    {
                                        "children": [], 
                                        "depends_on": "ESP32_SPIRAM_SUPPORT && ESP32_SPIRAM_SUPPORT", 
                                        "help": "If enabled the option,and add EXT_RAM_ATTR defined your variable,then your variable will be placed in\nPSRAM instead of internal memory, and placed most of variables of lwip,net802.11,pp,bluedroid library\nto external memory defaultly.\n", 
                                        "id": "SPIRAM_ALLOW_BSS_SEG_EXTERNAL_MEMORY", 
                                        "name": "SPIRAM_ALLOW_BSS_SEG_EXTERNAL_MEMORY", 
                                        "range": null, 
                                        "title": "Allow .bss segment placed in external memory", 
                                        "type": "bool"
                                    }, 
                                    {
                                        "children": [
                                            {
                                                "children": [], 
                                                "depends_on": "<choice SPIRAM_OCCUPY_SPI_HOST>", 
                                                "help": null, 
                                                "id": "SPIRAM_OCCUPY_HSPI_HOST", 
                                                "name": "SPIRAM_OCCUPY_HSPI_HOST", 
                                                "range": null, 
                                                "title": "HSPI host (SPI2)", 
                                                "type": "bool"
                                            }, 
                                            {
                                                "children": [], 
                                                "depends_on": "<choice SPIRAM_OCCUPY_SPI_HOST>", 
                                                "help": null, 
                                                "id": "SPIRAM_OCCUPY_VSPI_HOST", 
                                                "name": "SPIRAM_OCCUPY_VSPI_HOST", 
                                                "range": null, 
                                                "title": "VSPI host (SPI3)", 
                                                "type": "bool"
                                            }, 
                                            {
                                                "children": [], 
                                                "depends_on": "<choice SPIRAM_OCCUPY_SPI_HOST>", 
                                                "help": null, 
                                                "id": "SPIRAM_OCCUPY_NO_HOST", 
                                                "name": "SPIRAM_OCCUPY_NO_HOST", 
                                                "range": null, 
                                                "title": "Will not try to use any host, will abort if not able to use the PSRAM", 
                                                "type": "bool"
                                            }
                                        ], 
                                        "depends_on": "SPIRAM_SPEED_80M && ESP32_SPIRAM_SUPPORT", 
                                        "help": "When both flash and PSRAM is working under 80MHz, and the PSRAM is of type 32MBit, one of the HSPI/VSPI\nhost will be used to output the clock. Select which one to use here.\n", 
                                        "id": "component-config-esp32-specific-support-for-external-spi-connected-ram-spi-ram-config-spi-host-to-use-for-32mbit-psram", 
                                        "name": "SPIRAM_OCCUPY_SPI_HOST", 
                                        "title": "SPI host to use for 32MBit PSRAM", 
                                        "type": "choice"
                                    }, 
                                    {
                                        "children": [
                                            {
                                                "children": [], 
                                                "depends_on": "ESP32_SPIRAM_SUPPORT && ESP32_SPIRAM_SUPPORT", 
                                                "help": "The PSRAM CLOCK IO can be any unused GPIO, user can config it based on hardware design. If user use\n1.8V flash and 1.8V psram, this value can only be one of 6, 7, 8, 9, 10, 11, 16, 17.\n", 
                                                "id": "D0WD_PSRAM_CLK_IO", 
                                                "name": "D0WD_PSRAM_CLK_IO", 
                                                "range": null, 
                                                "title": "PSRAM CLK IO number", 
                                                "type": "int"
                                            }, 
                                            {
                                                "children": [], 
                                                "depends_on": "ESP32_SPIRAM_SUPPORT && ESP32_SPIRAM_SUPPORT", 
                                                "help": "The PSRAM CS IO can be any unused GPIO, user can config it based on hardware design. If user use\n1.8V flash and 1.8V psram, this value can only be one of 6, 7, 8, 9, 10, 11, 16, 17.\n", 
                                                "id": "D0WD_PSRAM_CS_IO", 
                                                "name": "D0WD_PSRAM_CS_IO", 
                                                "range": null, 
                                                "title": "PSRAM CS IO number", 
                                                "type": "int"
                                            }
                                        ], 
                                        "depends_on": "ESP32_SPIRAM_SUPPORT", 
                                        "id": "component-config-esp32-specific-support-for-external-spi-connected-ram-spi-ram-config-psram-clock-and-cs-io-for-esp32-dowd", 
                                        "title": "PSRAM clock and cs IO for ESP32-DOWD", 
                                        "type": "menu"
                                    }, 
                                    {
                                        "children": [
                                            {
                                                "children": [], 
                                                "depends_on": "ESP32_SPIRAM_SUPPORT && ESP32_SPIRAM_SUPPORT", 
                                                "help": "User can config it based on hardware design. For ESP32-D2WD chip, the psram can only be 1.8V psram,\nso this value can only be one of 6, 7, 8, 9, 10, 11, 16, 17.\n", 
                                                "id": "D2WD_PSRAM_CLK_IO", 
                                                "name": "D2WD_PSRAM_CLK_IO", 
                                                "range": null, 
                                                "title": "PSRAM CLK IO number", 
                                                "type": "int"
                                            }, 
                                            {
                                                "children": [], 
                                                "depends_on": "ESP32_SPIRAM_SUPPORT && ESP32_SPIRAM_SUPPORT", 
                                                "help": "User can config it based on hardware design. For ESP32-D2WD chip, the psram can only be 1.8V psram,\nso this value can only be one of 6, 7, 8, 9, 10, 11, 16, 17.\n", 
                                                "id": "D2WD_PSRAM_CS_IO", 
                                                "name": "D2WD_PSRAM_CS_IO", 
                                                "range": null, 
                                                "title": "PSRAM CS IO number", 
                                                "type": "int"
                                            }
                                        ], 
                                        "depends_on": "ESP32_SPIRAM_SUPPORT", 
                                        "id": "component-config-esp32-specific-support-for-external-spi-connected-ram-spi-ram-config-psram-clock-and-cs-io-for-esp32-d2wd", 
                                        "title": "PSRAM clock and cs IO for ESP32-D2WD", 
                                        "type": "menu"
                                    }, 
                                    {
                                        "children": [
                                            {
                                                "children": [], 
                                                "depends_on": "ESP32_SPIRAM_SUPPORT && ESP32_SPIRAM_SUPPORT", 
                                                "help": "The PSRAM CS IO can be any unused GPIO, user can config it based on hardware design.\n\nFor ESP32-PICO chip, the psram share clock with flash, so user do not need to configure the clock\nIO.\nFor the reference hardware design, please refer to\nhttps://www.espressif.com/sites/default/files/documentation/esp32-pico-d4_datasheet_en.pdf\n", 
                                                "id": "PICO_PSRAM_CS_IO", 
                                                "name": "PICO_PSRAM_CS_IO", 
                                                "range": null, 
                                                "title": "PSRAM CS IO number", 
                                                "type": "int"
                                            }
                                        ], 
                                        "depends_on": "ESP32_SPIRAM_SUPPORT", 
                                        "id": "component-config-esp32-specific-support-for-external-spi-connected-ram-spi-ram-config-psram-clock-and-cs-io-for-esp32-pico", 
                                        "title": "PSRAM clock and cs IO for ESP32-PICO", 
                                        "type": "menu"
                                    }, 
                                    {
                                        "children": [], 
                                        "depends_on": "(ESPTOOLPY_FLASHMODE_DIO || ESPTOOLPY_FLASHMODE_DOUT) && ESP32_SPIRAM_SUPPORT", 
                                        "help": "This value is ignored unless flash mode is set to DIO or DOUT and the SPI flash pins have been\noverriden by setting the eFuses SPI_PAD_CONFIG_xxx.\n\nWhen this is the case, the eFuse config only defines 3 of the 4 Quad I/O data pins. The WP pin (aka\nESP32 pin \"SD_DATA_3\" or SPI flash pin \"IO2\") is not specified in eFuse. And the psram only has QPI\nmode, the WP pin is necessary, so we need to configure this value here.\n\nWhen flash mode is set to QIO or QOUT, the PSRAM WP pin will be set as the value configured in\nbootloader.\n\nFor ESP32-PICO chip, the default value of this config should be 7.\n", 
                                        "id": "SPIRAM_SPIWP_SD3_PIN", 
                                        "name": "SPIRAM_SPIWP_SD3_PIN", 
                                        "range": null, 
                                        "title": "SPI PSRAM WP(SD3) Pin when customising pins via eFuse (read help)", 
                                        "type": "int"
                                    }, 
                                    {
                                        "children": [], 
                                        "depends_on": "ESP32_SPIRAM_SUPPORT && ESP32_SPIRAM_SUPPORT", 
                                        "help": "Enable this option to fix single bit errors inside 64Mbit PSRAM.\n\nSome 64Mbit PSRAM chips have a hardware issue in the RAM which causes bit errors at multiple\nfixed bit positions.\n\nNote: If this option is enabled, the 64Mbit PSRAM chip will appear to be 32Mbit in size.\nApplications will not be affected unless the use the esp_himem APIs, which are not supported\nin 2T mode.\n", 
                                        "id": "SPIRAM_2T_MODE", 
                                        "name": "SPIRAM_2T_MODE", 
                                        "range": null, 
                                        "title": "Enable SPI PSRAM 2T mode", 
                                        "type": "bool"
                                    }
                                ], 
                                "depends_on": "ESP32_SPIRAM_SUPPORT", 
                                "id": "component-config-esp32-specific-support-for-external-spi-connected-ram-spi-ram-config", 
                                "title": "SPI RAM config", 
                                "type": "menu"
                            }
                        ], 
                        "depends_on": null, 
                        "help": "This enables support for an external SPI RAM chip, connected in parallel with the\nmain SPI flash chip.\n", 
                        "id": "ESP32_SPIRAM_SUPPORT", 
                        "name": "ESP32_SPIRAM_SUPPORT", 
                        "range": null, 
                        "title": "Support for external, SPI-connected RAM", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": null, 
                        "id": "ESP32_MEMMAP_TRACEMEM", 
                        "name": "ESP32_MEMMAP_TRACEMEM", 
                        "range": null, 
                        "title": null, 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": null, 
                        "id": "ESP32_MEMMAP_TRACEMEM_TWOBANKS", 
                        "name": "ESP32_MEMMAP_TRACEMEM_TWOBANKS", 
                        "range": null, 
                        "title": null, 
                        "type": "bool"
                    }, 
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "ESP32_TRAX && !FREERTOS_UNICORE", 
                                "help": "The ESP32 contains a feature which allows you to trace the execution path the processor\nhas taken through the program. This is stored in a chunk of 32K (16K for single-processor)\nof memory that can't be used for general purposes anymore. Disable this if you do not know\nwhat this is.\n\n# Memory to reverse for trace, used in linker script\n", 
                                "id": "ESP32_TRAX_TWOBANKS", 
                                "name": "ESP32_TRAX_TWOBANKS", 
                                "range": null, 
                                "title": "Reserve memory for tracing both pro as well as app cpu execution", 
                                "type": "bool"
                            }
                        ], 
                        "depends_on": null, 
                        "help": "The ESP32 contains a feature which allows you to trace the execution path the processor\nhas taken through the program. This is stored in a chunk of 32K (16K for single-processor)\nof memory that can't be used for general purposes anymore. Disable this if you do not know\nwhat this is.\n", 
                        "id": "ESP32_TRAX", 
                        "name": "ESP32_TRAX", 
                        "range": null, 
                        "title": "Use TRAX tracing feature", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": null, 
                        "id": "ESP32_TRACEMEM_RESERVE_DRAM", 
                        "name": "ESP32_TRACEMEM_RESERVE_DRAM", 
                        "range": null, 
                        "title": null, 
                        "type": "hex"
                    }, 
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_UNIVERSAL_MAC_ADDRESSES>", 
                                "help": null, 
                                "id": "ESP32_UNIVERSAL_MAC_ADDRESSES_TWO", 
                                "name": "ESP32_UNIVERSAL_MAC_ADDRESSES_TWO", 
                                "range": null, 
                                "title": "Two", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_UNIVERSAL_MAC_ADDRESSES>", 
                                "help": null, 
                                "id": "ESP32_UNIVERSAL_MAC_ADDRESSES_FOUR", 
                                "name": "ESP32_UNIVERSAL_MAC_ADDRESSES_FOUR", 
                                "range": null, 
                                "title": "Four", 
                                "type": "bool"
                            }
                        ], 
                        "depends_on": null, 
                        "help": "Configure the number of universally administered (by IEEE) MAC addresses.\nDuring initialisation, MAC addresses for each network interface are generated or derived from a\nsingle base MAC address.\nIf the number of universal MAC addresses is four, all four interfaces (WiFi station, WiFi softap,\nBluetooth and Ethernet) receive a universally administered MAC address. These are generated\nsequentially by adding 0, 1, 2 and 3 (respectively) to the final octet of the base MAC address.\nIf the number of universal MAC addresses is two, only two interfaces (WiFi station and Bluetooth)\nreceive a universally administered MAC address. These are generated sequentially by adding 0\nand 1 (respectively) to the base MAC address. The remaining two interfaces (WiFi softap and Ethernet)\nreceive local MAC addresses. These are derived from the universal WiFi station and Bluetooth MAC\naddresses, respectively.\nWhen using the default (Espressif-assigned) base MAC address, either setting can be used. When using\na custom universal MAC address range, the correct setting will depend on the allocation of MAC\naddresses in this range (either 2 or 4 per device.)\n", 
                        "id": "component-config-esp32-specific-number-of-universally-administered-by-ieee-mac-address", 
                        "name": "ESP32_UNIVERSAL_MAC_ADDRESSES", 
                        "title": "Number of universally administered (by IEEE) MAC address", 
                        "type": "choice"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": null, 
                        "id": "ESP32_UNIVERSAL_MAC_ADDRESSES", 
                        "name": "ESP32_UNIVERSAL_MAC_ADDRESSES", 
                        "range": null, 
                        "title": null, 
                        "type": "int"
                    }, 
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": null, 
                                "help": "Bytes of memory to reserve for ULP coprocessor firmware & data.\n\nData is reserved at the beginning of RTC slow memory.\n", 
                                "id": "ESP32_ULP_COPROC_RESERVE_MEM", 
                                "name": "ESP32_ULP_COPROC_RESERVE_MEM", 
                                "range": [
                                    0, 
                                    0
                                ], 
                                "title": "RTC slow memory reserved for coprocessor", 
                                "type": "int"
                            }
                        ], 
                        "depends_on": null, 
                        "help": "Set to 'y' if you plan to load a firmware for the coprocessor.\n\nIf this option is enabled, further coprocessor configuration will appear in the Components menu.\n", 
                        "id": "ESP32_ULP_COPROC_ENABLED", 
                        "name": "ESP32_ULP_COPROC_ENABLED", 
                        "range": null, 
                        "title": "Enable Ultra Low Power (ULP) Coprocessor", 
                        "type": "bool"
                    }, 
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_PANIC>", 
                                "help": "Outputs the relevant registers over the serial port and halt the\nprocessor. Needs a manual reset to restart.\n", 
                                "id": "ESP32_PANIC_PRINT_HALT", 
                                "name": "ESP32_PANIC_PRINT_HALT", 
                                "range": null, 
                                "title": "Print registers and halt", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_PANIC>", 
                                "help": "Outputs the relevant registers over the serial port and immediately\nreset the processor.\n", 
                                "id": "ESP32_PANIC_PRINT_REBOOT", 
                                "name": "ESP32_PANIC_PRINT_REBOOT", 
                                "range": null, 
                                "title": "Print registers and reboot", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_PANIC>", 
                                "help": "Just resets the processor without outputting anything\n", 
                                "id": "ESP32_PANIC_SILENT_REBOOT", 
                                "name": "ESP32_PANIC_SILENT_REBOOT", 
                                "range": null, 
                                "title": "Silent reboot", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_PANIC>", 
                                "help": "Invoke gdbstub on the serial port, allowing for gdb to attach to it to do a postmortem\nof the crash.\n", 
                                "id": "ESP32_PANIC_GDBSTUB", 
                                "name": "ESP32_PANIC_GDBSTUB", 
                                "range": null, 
                                "title": "Invoke GDBStub", 
                                "type": "bool"
                            }
                        ], 
                        "depends_on": null, 
                        "help": "If FreeRTOS detects unexpected behaviour or an unhandled exception, the panic handler is\ninvoked. Configure the panic handlers action here.\n", 
                        "id": "component-config-esp32-specific-panic-handler-behaviour", 
                        "name": "ESP32_PANIC", 
                        "title": "Panic handler behaviour", 
                        "type": "choice"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": "The FreeRTOS panic and unhandled exception handers can detect a JTAG OCD debugger and\ninstead of panicking, have the debugger stop on the offending instruction.\n", 
                        "id": "ESP32_DEBUG_OCDAWARE", 
                        "name": "ESP32_DEBUG_OCDAWARE", 
                        "range": null, 
                        "title": "Make exception and panic handlers JTAG/OCD aware", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "!ESP32_TRAX", 
                        "help": "Debug stubs are used by OpenOCD to execute pre-compiled onboard code which does some useful debugging,\ne.g. GCOV data dump.\n", 
                        "id": "ESP32_DEBUG_STUBS_ENABLE", 
                        "name": "ESP32_DEBUG_STUBS_ENABLE", 
                        "range": null, 
                        "title": "OpenOCD debug stubs", 
                        "type": "bool"
                    }, 
                    {
                        "children": [
                            {
                                "children": [
                                    {
                                        "children": [], 
                                        "depends_on": "<choice ESP32_BROWNOUT_DET_LVL_SEL>", 
                                        "help": null, 
                                        "id": "ESP32_BROWNOUT_DET_LVL_SEL_0", 
                                        "name": "ESP32_BROWNOUT_DET_LVL_SEL_0", 
                                        "range": null, 
                                        "title": "2.43V +/- 0.05", 
                                        "type": "bool"
                                    }, 
                                    {
                                        "children": [], 
                                        "depends_on": "<choice ESP32_BROWNOUT_DET_LVL_SEL>", 
                                        "help": null, 
                                        "id": "ESP32_BROWNOUT_DET_LVL_SEL_1", 
                                        "name": "ESP32_BROWNOUT_DET_LVL_SEL_1", 
                                        "range": null, 
                                        "title": "2.48V +/- 0.05", 
                                        "type": "bool"
                                    }, 
                                    {
                                        "children": [], 
                                        "depends_on": "<choice ESP32_BROWNOUT_DET_LVL_SEL>", 
                                        "help": null, 
                                        "id": "ESP32_BROWNOUT_DET_LVL_SEL_2", 
                                        "name": "ESP32_BROWNOUT_DET_LVL_SEL_2", 
                                        "range": null, 
                                        "title": "2.58V +/- 0.05", 
                                        "type": "bool"
                                    }, 
                                    {
                                        "children": [], 
                                        "depends_on": "<choice ESP32_BROWNOUT_DET_LVL_SEL>", 
                                        "help": null, 
                                        "id": "ESP32_BROWNOUT_DET_LVL_SEL_3", 
                                        "name": "ESP32_BROWNOUT_DET_LVL_SEL_3", 
                                        "range": null, 
                                        "title": "2.62V +/- 0.05", 
                                        "type": "bool"
                                    }, 
                                    {
                                        "children": [], 
                                        "depends_on": "<choice ESP32_BROWNOUT_DET_LVL_SEL>", 
                                        "help": null, 
                                        "id": "ESP32_BROWNOUT_DET_LVL_SEL_4", 
                                        "name": "ESP32_BROWNOUT_DET_LVL_SEL_4", 
                                        "range": null, 
                                        "title": "2.67V +/- 0.05", 
                                        "type": "bool"
                                    }, 
                                    {
                                        "children": [], 
                                        "depends_on": "<choice ESP32_BROWNOUT_DET_LVL_SEL>", 
                                        "help": null, 
                                        "id": "ESP32_BROWNOUT_DET_LVL_SEL_5", 
                                        "name": "ESP32_BROWNOUT_DET_LVL_SEL_5", 
                                        "range": null, 
                                        "title": "2.70V +/- 0.05", 
                                        "type": "bool"
                                    }, 
                                    {
                                        "children": [], 
                                        "depends_on": "<choice ESP32_BROWNOUT_DET_LVL_SEL>", 
                                        "help": null, 
                                        "id": "ESP32_BROWNOUT_DET_LVL_SEL_6", 
                                        "name": "ESP32_BROWNOUT_DET_LVL_SEL_6", 
                                        "range": null, 
                                        "title": "2.77V +/- 0.05", 
                                        "type": "bool"
                                    }, 
                                    {
                                        "children": [], 
                                        "depends_on": "<choice ESP32_BROWNOUT_DET_LVL_SEL>", 
                                        "help": null, 
                                        "id": "ESP32_BROWNOUT_DET_LVL_SEL_7", 
                                        "name": "ESP32_BROWNOUT_DET_LVL_SEL_7", 
                                        "range": null, 
                                        "title": "2.80V +/- 0.05", 
                                        "type": "bool"
                                    }
                                ], 
                                "depends_on": "ESP32_BROWNOUT_DET", 
                                "help": "The brownout detector will reset the chip when the supply voltage is approximately\nbelow this level. Note that there may be some variation of brownout voltage level\nbetween each ESP32 chip.\n\n#The voltage levels here are estimates, more work needs to be done to figure out the exact voltages\n#of the brownout threshold levels.\n", 
                                "id": "component-config-esp32-specific-hardware-brownout-detect-reset-brownout-voltage-level", 
                                "name": "ESP32_BROWNOUT_DET_LVL_SEL", 
                                "title": "Brownout voltage level", 
                                "type": "choice"
                            }
                        ], 
                        "depends_on": null, 
                        "help": "The ESP32 has a built-in brownout detector which can detect if the voltage is lower than\na specific value. If this happens, it will reset the chip in order to prevent unintended\nbehaviour.\n", 
                        "id": "ESP32_BROWNOUT_DET", 
                        "name": "ESP32_BROWNOUT_DET", 
                        "range": null, 
                        "title": "Hardware brownout detect & reset", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": null, 
                        "id": "ESP32_BROWNOUT_DET_LVL", 
                        "name": "ESP32_BROWNOUT_DET_LVL", 
                        "range": null, 
                        "title": null, 
                        "type": "int"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "ESP32_BROWNOUT_DET", 
                        "help": "When brownout reset occurs, reduce PHY TX power to keep the code running\n\n# Note about the use of \"FRC1\" name: currently FRC1 timer is not used for\n# high resolution timekeeping anymore. Instead the esp_timer API, implemented\n# using FRC2 timer, is used.\n# FRC1 name in the option name is kept for compatibility.\n", 
                        "id": "ESP32_REDUCE_PHY_TX_POWER", 
                        "name": "ESP32_REDUCE_PHY_TX_POWER", 
                        "range": null, 
                        "title": "Reduce PHY TX power when brownout reset", 
                        "type": "bool"
                    }, 
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_TIME_SYSCALL>", 
                                "help": null, 
                                "id": "ESP32_TIME_SYSCALL_USE_RTC_FRC1", 
                                "name": "ESP32_TIME_SYSCALL_USE_RTC_FRC1", 
                                "range": null, 
                                "title": "RTC and high-resolution timer", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_TIME_SYSCALL>", 
                                "help": null, 
                                "id": "ESP32_TIME_SYSCALL_USE_RTC", 
                                "name": "ESP32_TIME_SYSCALL_USE_RTC", 
                                "range": null, 
                                "title": "RTC", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_TIME_SYSCALL>", 
                                "help": null, 
                                "id": "ESP32_TIME_SYSCALL_USE_FRC1", 
                                "name": "ESP32_TIME_SYSCALL_USE_FRC1", 
                                "range": null, 
                                "title": "High-resolution timer", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_TIME_SYSCALL>", 
                                "help": null, 
                                "id": "ESP32_TIME_SYSCALL_USE_NONE", 
                                "name": "ESP32_TIME_SYSCALL_USE_NONE", 
                                "range": null, 
                                "title": "None", 
                                "type": "bool"
                            }
                        ], 
                        "depends_on": null, 
                        "help": "This setting defines which hardware timers are used to\nimplement 'gettimeofday' and 'time' functions in C library.\n\n- If both high-resolution and RTC timers are used, timekeeping will\n  continue in deep sleep. Time will be reported at 1 microsecond\n  resolution. This is the default, and the recommended option.\n- If only high-resolution timer is used, gettimeofday will\n  provide time at microsecond resolution.\n  Time will not be preserved when going into deep sleep mode.\n- If only RTC timer is used, timekeeping will continue in\n  deep sleep, but time will be measured at 6.(6) microsecond\n  resolution. Also the gettimeofday function itself may take\n  longer to run.\n- If no timers are used, gettimeofday and time functions\n  return -1 and set errno to ENOSYS.\n- When RTC is used for timekeeping, two RTC_STORE registers are\n  used to keep time in deep sleep mode.\n", 
                        "id": "component-config-esp32-specific-timers-used-for-gettimeofday-function", 
                        "name": "ESP32_TIME_SYSCALL", 
                        "title": "Timers used for gettimeofday function", 
                        "type": "choice"
                    }, 
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_RTC_CLK_SRC>", 
                                "help": null, 
                                "id": "ESP32_RTC_CLK_SRC_INT_RC", 
                                "name": "ESP32_RTC_CLK_SRC_INT_RC", 
                                "range": null, 
                                "title": "Internal 150kHz RC oscillator", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_RTC_CLK_SRC>", 
                                "help": null, 
                                "id": "ESP32_RTC_CLK_SRC_EXT_CRYS", 
                                "name": "ESP32_RTC_CLK_SRC_EXT_CRYS", 
                                "range": null, 
                                "title": "External 32kHz crystal", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_RTC_CLK_SRC>", 
                                "help": null, 
                                "id": "ESP32_RTC_CLK_SRC_EXT_OSC", 
                                "name": "ESP32_RTC_CLK_SRC_EXT_OSC", 
                                "range": null, 
                                "title": "External 32kHz oscillator at 32K_XP pin", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_RTC_CLK_SRC>", 
                                "help": null, 
                                "id": "ESP32_RTC_CLK_SRC_INT_8MD256", 
                                "name": "ESP32_RTC_CLK_SRC_INT_8MD256", 
                                "range": null, 
                                "title": "Internal 8.5MHz oscillator, divided by 256 (~33kHz)", 
                                "type": "bool"
                            }
                        ], 
                        "depends_on": null, 
                        "help": "Choose which clock is used as RTC clock source.\n\n- \"Internal 150kHz oscillator\" option provides lowest deep sleep current\n  consumption, and does not require extra external components. However\n  frequency stability with respect to temperature is poor, so time may\n  drift in deep/light sleep modes.\n- \"External 32kHz crystal\" provides better frequency stability, at the\n  expense of slightly higher (1uA) deep sleep current consumption.\n- \"External 32kHz oscillator\" allows using 32kHz clock generated by an\n  external circuit. In this case, external clock signal must be connected\n  to 32K_XP pin. Amplitude should be <1.2V in case of sine wave signal,\n  and <1V in case of square wave signal. Common mode voltage should be\n  0.1 < Vcm < 0.5Vamp, where Vamp is the signal amplitude.\n  Additionally, 1nF capacitor must be connected between 32K_XN pin and\n  ground. 32K_XN pin can not be used as a GPIO in this case.\n- \"Internal 8.5MHz oscillator divided by 256\" option results in higher\n  deep sleep current (by 5uA) but has better frequency stability than\n  the internal 150kHz oscillator. It does not require external components.\n", 
                        "id": "component-config-esp32-specific-rtc-clock-source", 
                        "name": "ESP32_RTC_CLK_SRC", 
                        "title": "RTC clock source", 
                        "type": "choice"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "ESP32_RTC_CLK_SRC_EXT_CRYS", 
                        "help": "Choose which additional current is used for rtc external crystal.\n\n- With some 32kHz crystal configurations, the X32N and X32P pins may not\n  have enough drive strength to keep the crystal oscillating during deep sleep.\n  If this option is enabled, additional current from touchpad 9 is provided\n  internally to drive the 32kHz crystal. If this option is enabled, deep sleep current\n  is slightly higher (4-5uA) and the touchpad and ULP wakeup sources are not available.\n", 
                        "id": "ESP32_RTC_EXT_CRYST_ADDIT_CURRENT", 
                        "name": "ESP32_RTC_EXT_CRYST_ADDIT_CURRENT", 
                        "range": null, 
                        "title": "Additional current for external 32kHz crystal", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": "When the startup code initializes RTC_SLOW_CLK, it can perform\ncalibration by comparing the RTC_SLOW_CLK frequency with main XTAL\nfrequency. This option sets the number of RTC_SLOW_CLK cycles measured\nby the calibration routine. Higher numbers increase calibration\nprecision, which may be important for applications which spend a lot of\ntime in deep sleep. Lower numbers reduce startup time.\n\nWhen this option is set to 0, clock calibration will not be performed at\nstartup, and approximate clock frequencies will be assumed:\n\n- 150000 Hz if internal RC oscillator is used as clock source. For this use value 1024.\n- 32768 Hz if the 32k crystal oscillator is used. For this use value 3000 or more.\n  In case more value will help improve the definition of the launch of the crystal.\n  If the crystal could not start, it will be switched to internal RC.\n", 
                        "id": "ESP32_RTC_CLK_CAL_CYCLES", 
                        "name": "ESP32_RTC_CLK_CAL_CYCLES", 
                        "range": [
                            0, 
                            32766
                        ], 
                        "title": "Number of cycles for RTC_SLOW_CLK calibration", 
                        "type": "int"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": "Number of attempts to repeat 32k XTAL calibration\nbefore giving up and switching to the internal RC.\nIncrease this option if the 32k crystal oscillator\ndoes not start and switches to internal RC.\n", 
                        "id": "ESP32_RTC_XTAL_CAL_RETRY", 
                        "name": "ESP32_RTC_XTAL_CAL_RETRY", 
                        "range": null, 
                        "title": "Number of attempts to repeat 32k XTAL calibration", 
                        "type": "int"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "ESP32_RTC_CLK_SRC_EXT_CRYS", 
                        "help": "To reduce the startup time of an external RTC crystal,\nwe bootstrap it with a 32kHz square wave for a fixed number of cycles.\nSetting 0 will disable bootstrapping (if disabled, the crystal may take\nlonger to start up or fail to oscillate under some conditions).\n\nIf this value is too high, a faulty crystal may initially start and then fail.\nIf this value is too low, an otherwise good crystal may not start.\n\nTo accurately determine if the crystal has started,\nset a larger \"Number of cycles for RTC_SLOW_CLK calibration\" (about 3000).\n", 
                        "id": "ESP32_RTC_XTAL_BOOTSTRAP_CYCLES", 
                        "name": "ESP32_RTC_XTAL_BOOTSTRAP_CYCLES", 
                        "range": null, 
                        "title": "Bootstrap cycles for external 32kHz crystal", 
                        "type": "int"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": "When ESP32 exits deep sleep, the CPU and the flash chip are powered on\nat the same time. CPU will run deep sleep stub first, and then\nproceed to load code from flash. Some flash chips need sufficient\ntime to pass between power on and first read operation. By default,\nwithout any extra delay, this time is approximately 900us, although\nsome flash chip types need more than that.\n\nBy default extra delay is set to 2000us. When optimizing startup time\nfor applications which require it, this value may be reduced.\n\nIf you are seeing \"flash read err, 1000\" message printed to the\nconsole after deep sleep reset, try increasing this value.\n", 
                        "id": "ESP32_DEEP_SLEEP_WAKEUP_DELAY", 
                        "name": "ESP32_DEEP_SLEEP_WAKEUP_DELAY", 
                        "range": [
                            0, 
                            5000
                        ], 
                        "title": "Extra delay in deep sleep wake stub (in us)", 
                        "type": "int"
                    }, 
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_XTAL_FREQ_SEL>", 
                                "help": null, 
                                "id": "ESP32_XTAL_FREQ_40", 
                                "name": "ESP32_XTAL_FREQ_40", 
                                "range": null, 
                                "title": "40 MHz", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_XTAL_FREQ_SEL>", 
                                "help": null, 
                                "id": "ESP32_XTAL_FREQ_26", 
                                "name": "ESP32_XTAL_FREQ_26", 
                                "range": null, 
                                "title": "26 MHz", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice ESP32_XTAL_FREQ_SEL>", 
                                "help": null, 
                                "id": "ESP32_XTAL_FREQ_AUTO", 
                                "name": "ESP32_XTAL_FREQ_AUTO", 
                                "range": null, 
                                "title": "Autodetect", 
                                "type": "bool"
                            }
                        ], 
                        "depends_on": null, 
                        "help": "ESP32 currently supports the following XTAL frequencies:\n\n- 26 MHz\n- 40 MHz\n\nStartup code can automatically estimate XTAL frequency. This feature\nuses the internal 8MHz oscillator as a reference. Because the internal\noscillator frequency is temperature dependent, it is not recommended\nto use automatic XTAL frequency detection in applications which need\nto work at high ambient temperatures and use high-temperature\nqualified chips and modules.\n", 
                        "id": "component-config-esp32-specific-main-xtal-frequency", 
                        "name": "ESP32_XTAL_FREQ_SEL", 
                        "title": "Main XTAL frequency", 
                        "type": "choice"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": null, 
                        "id": "ESP32_XTAL_FREQ", 
                        "name": "ESP32_XTAL_FREQ", 
                        "range": null, 
                        "title": null, 
                        "type": "int"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": "If set, the first time the app boots it will disable the BASIC ROM Console\npermanently (by burning an eFuse).\n\nOtherwise, the BASIC ROM Console starts on reset if no valid bootloader is\nread from the flash.\n\n(Enabling secure boot also disables the BASIC ROM Console by default.)\n", 
                        "id": "ESP32_DISABLE_BASIC_ROM_CONSOLE", 
                        "name": "ESP32_DISABLE_BASIC_ROM_CONSOLE", 
                        "range": null, 
                        "title": "Permanently disable BASIC ROM Console", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "!BT_ENABLED", 
                        "help": "If enabled, this disables the linking of binary libraries in the application build. Note\nthat after enabling this Wi-Fi/Bluetooth will not work.\n", 
                        "id": "ESP32_NO_BLOBS", 
                        "name": "ESP32_NO_BLOBS", 
                        "range": null, 
                        "title": "No Binary Blobs", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": "Bootloaders before IDF v2.1 did less initialisation of the\nsystem clock. This setting needs to be enabled to build an app\nwhich can be booted by these older bootloaders.\n\nIf this setting is enabled, the app can be booted by any bootloader\nfrom IDF v1.0 up to the current version.\n\nIf this setting is disabled, the app can only be booted by bootloaders\nfrom IDF v2.1 or newer.\n\nEnabling this setting adds approximately 1KB to the app's IRAM usage.\n", 
                        "id": "ESP32_COMPATIBLE_PRE_V2_1_BOOTLOADERS", 
                        "name": "ESP32_COMPATIBLE_PRE_V2_1_BOOTLOADERS", 
                        "range": null, 
                        "title": "App compatible with bootloaders before IDF v2.1", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "FREERTOS_UNICORE", 
                        "help": "This option allows to place .rtc_data and .rtc_rodata sections into\nRTC fast memory segment to free the slow memory region for ULP programs.\nThis option depends on the CONFIG_FREERTOS_UNICORE option because RTC fast memory\ncan be accessed only by PRO_CPU core.\n", 
                        "id": "ESP32_RTCDATA_IN_FAST_MEM", 
                        "name": "ESP32_RTCDATA_IN_FAST_MEM", 
                        "range": null, 
                        "title": "Place RTC_DATA_ATTR and RTC_RODATA_ATTR variables into RTC fast memory segment", 
                        "type": "bool"
                    }, 
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "ESP32_USE_FIXED_STATIC_RAM_SIZE", 
                                "help": "RAM size dedicated for static variables (.data & .bss sections).\nPlease note that the actual length will be reduced by BT_RESERVE_DRAM if Bluetooth\ncontroller is enabled.\n", 
                                "id": "ESP32_FIXED_STATIC_RAM_SIZE", 
                                "name": "ESP32_FIXED_STATIC_RAM_SIZE", 
                                "range": null, 
                                "title": "Fixed Static RAM size", 
                                "type": "hex"
                            }
                        ], 
                        "depends_on": null, 
                        "help": "If this option is disabled, the DRAM part of the heap starts right after the .bss section,\nwithin the dram0_0 region. As a result, adding or removing some static variables\nwill change the available heap size.\n\nIf this option is enabled, the DRAM part of the heap starts right after the dram0_0 region,\nwhere its length is set with ESP32_FIXED_STATIC_RAM_SIZE\n", 
                        "id": "ESP32_USE_FIXED_STATIC_RAM_SIZE", 
                        "name": "ESP32_USE_FIXED_STATIC_RAM_SIZE", 
                        "range": null, 
                        "title": "Use fixed static RAM size", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": "To prevent interrupting DPORT workarounds,\nneed to disable interrupt with a maximum used level in the system.\n", 
                        "id": "ESP32_DPORT_DIS_INTERRUPT_LVL", 
                        "name": "ESP32_DPORT_DIS_INTERRUPT_LVL", 
                        "range": null, 
                        "title": "Disable the interrupt level for the DPORT workarounds", 
                        "type": "int"
                    }
                ], 
                "depends_on": null, 
                "id": "component-config-esp32-specific", 
                "title": "ESP32-specific", 
                "type": "menu"
            }, 
            {
                "children": [
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "PM_ENABLE", 
                                "help": "If enabled, startup code configures dynamic frequency scaling.\nMax CPU frequency is set to CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ setting,\nmin frequency is set to XTAL frequency.\nIf disabled, DFS will not be active until the application\nconfigures it using esp_pm_configure function.\n", 
                                "id": "PM_DFS_INIT_AUTO", 
                                "name": "PM_DFS_INIT_AUTO", 
                                "range": null, 
                                "title": "Enable dynamic frequency scaling (DFS) at startup", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "PM_ENABLE && (ESP32_TIME_SYSCALL_USE_RTC || ESP32_TIME_SYSCALL_USE_RTC_FRC1)", 
                                "help": "When APB clock frequency changes, high-resolution timer (esp_timer)\nscale and base value need to be adjusted. Each adjustment may cause\nsmall error, and over time such small errors may cause time drift.\nIf this option is enabled, RTC timer will be used as a reference to\ncompensate for the drift.\nIt is recommended that this option is only used if 32k XTAL is selected\nas RTC clock source.\n", 
                                "id": "PM_USE_RTC_TIMER_REF", 
                                "name": "PM_USE_RTC_TIMER_REF", 
                                "range": null, 
                                "title": "Use RTC timer to prevent time drift (EXPERIMENTAL)", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "PM_ENABLE", 
                                "help": "If enabled, esp_pm_* functions will keep track of the amount of time\neach of the power management locks has been held, and esp_pm_dump_locks\nfunction will print this information.\nThis feature can be used to analyze which locks are preventing the chip\nfrom going into a lower power state, and see what time the chip spends\nin each power saving mode. This feature does incur some run-time\noverhead, so should typically be disabled in production builds.\n", 
                                "id": "PM_PROFILING", 
                                "name": "PM_PROFILING", 
                                "range": null, 
                                "title": "Enable profiling counters for PM locks", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "PM_ENABLE", 
                                "help": "If enabled, some GPIOs will be used to signal events such as RTOS ticks,\nfrequency switching, entry/exit from idle state. Refer to pm_trace.c\nfile for the list of GPIOs.\nThis feature is intended to be used when analyzing/debugging behavior\nof power management implementation, and should be kept disabled in\napplications.\n", 
                                "id": "PM_TRACE", 
                                "name": "PM_TRACE", 
                                "range": null, 
                                "title": "Enable debug tracing of PM using GPIOs", 
                                "type": "bool"
                            }
                        ], 
                        "depends_on": null, 
                        "help": "If enabled, application is compiled with support for power management.\nThis option has run-time overhead (increased interrupt latency,\nlonger time to enter idle state), and it also reduces accuracy of\nRTOS ticks and timers used for timekeeping.\nEnable this option if application uses power management APIs.\n", 
                        "id": "PM_ENABLE", 
                        "name": "PM_ENABLE", 
                        "range": null, 
                        "title": "Support for power management", 
                        "type": "bool"
                    }
                ], 
                "depends_on": null, 
                "id": "component-config-power-management", 
                "title": "Power Management", 
                "type": "menu"
            }, 
            {
                "children": [
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": "If enabled, esp_timer_dump will dump information such as number of times the timer was started, number of\ntimes the timer has triggered, and the total time it took for the callback to run. This option has some\neffect on timer performance and the amount of memory used for timer storage, and should only be used for\ndebugging/testing purposes.\n", 
                        "id": "ESP_TIMER_PROFILING", 
                        "name": "ESP_TIMER_PROFILING", 
                        "range": null, 
                        "title": "Enable esp_timer profiling features", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": "Functions esp_err_to_name() and esp_err_to_name_r() return string representations of error codes from a\npre-generated lookup table. This option can be used to turn off the use of the look-up table in order to\nsave memory but this comes at the price of sacrificing distinguishable (meaningful) output string\nrepresentations.\n", 
                        "id": "ESP_ERR_TO_NAME_LOOKUP", 
                        "name": "ESP_ERR_TO_NAME_LOOKUP", 
                        "range": null, 
                        "title": "Enable lookup of error code strings", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": "Config system event queue size in different application.\n", 
                        "id": "ESP_SYSTEM_EVENT_QUEUE_SIZE", 
                        "name": "ESP_SYSTEM_EVENT_QUEUE_SIZE", 
                        "range": null, 
                        "title": "System event queue size", 
                        "type": "int"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": "Config system event task stack size in different application.\n", 
                        "id": "ESP_SYSTEM_EVENT_TASK_STACK_SIZE", 
                        "name": "ESP_SYSTEM_EVENT_TASK_STACK_SIZE", 
                        "range": null, 
                        "title": "Event loop task stack size", 
                        "type": "int"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": "Configure the \"main task\" stack size. This is the stack of the task\nwhich calls app_main(). If app_main() returns then this task is deleted\nand its stack memory is freed.\n", 
                        "id": "ESP_MAIN_TASK_STACK_SIZE", 
                        "name": "ESP_MAIN_TASK_STACK_SIZE", 
                        "range": null, 
                        "title": "Main task stack size", 
                        "type": "int"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": "Configure the IPC tasks stack size. One IPC task runs on each core\n(in dual core mode), and allows for cross-core function calls.\n\nSee IPC documentation for more details.\n\nThe default stack size should be enough for most common use cases.\nIt can be shrunk if you are sure that you do not use any custom\nIPC functionality.\n", 
                        "id": "ESP_IPC_TASK_STACK_SIZE", 
                        "name": "ESP_IPC_TASK_STACK_SIZE", 
                        "range": [
                            512, 
                            65536
                        ], 
                        "title": "Inter-Processor Call (IPC) task stack size", 
                        "type": "int"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": "Configure the stack size of esp_timer/ets_timer task. This task is used\nto dispatch callbacks of timers created using ets_timer and esp_timer\nAPIs. If you are seing stack overflow errors in timer task, increase\nthis value.\n\nNote that this is not the same as FreeRTOS timer task. To configure\nFreeRTOS timer task size, see \"FreeRTOS timer task stack size\" option\nin \"FreeRTOS\" menu.\n", 
                        "id": "ESP_TIMER_TASK_STACK_SIZE", 
                        "name": "ESP_TIMER_TASK_STACK_SIZE", 
                        "range": [
                            2048, 
                            65536
                        ], 
                        "title": "High-resolution timer task stack size", 
                        "type": "int"
                    }, 
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "<choice ESP_CONSOLE_UART>", 
                                "help": null, 
                                "id": "ESP_CONSOLE_UART_DEFAULT", 
                                "name": "ESP_CONSOLE_UART_DEFAULT", 
                                "range": null, 
                                "title": "Default: UART0, TX=GPIO1, RX=GPIO3", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice ESP_CONSOLE_UART>", 
                                "help": null, 
                                "id": "ESP_CONSOLE_UART_CUSTOM", 
                                "name": "ESP_CONSOLE_UART_CUSTOM", 
                                "range": null, 
                                "title": "Custom", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice ESP_CONSOLE_UART>", 
                                "help": null, 
                                "id": "ESP_CONSOLE_UART_NONE", 
                                "name": "ESP_CONSOLE_UART_NONE", 
                                "range": null, 
                                "title": "None", 
                                "type": "bool"
                            }
                        ], 
                        "depends_on": null, 
                        "help": "Select whether to use UART for console output (through stdout and stderr).\n\n- Default is to use UART0 on pins GPIO1(TX) and GPIO3(RX).\n- If \"Custom\" is selected, UART0 or UART1 can be chosen,\n  and any pins can be selected.\n- If \"None\" is selected, there will be no console output on any UART, except\n  for initial output from ROM bootloader. This output can be further suppressed by\n  bootstrapping GPIO13 pin to low logic level.\n", 
                        "id": "component-config-common-esp-related-uart-for-console-output", 
                        "name": "ESP_CONSOLE_UART", 
                        "title": "UART for console output", 
                        "type": "choice"
                    }, 
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "<choice ESP_CONSOLE_UART_NUM>", 
                                "help": null, 
                                "id": "ESP_CONSOLE_UART_CUSTOM_NUM_0", 
                                "name": "ESP_CONSOLE_UART_CUSTOM_NUM_0", 
                                "range": null, 
                                "title": "UART0", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice ESP_CONSOLE_UART_NUM>", 
                                "help": null, 
                                "id": "ESP_CONSOLE_UART_CUSTOM_NUM_1", 
                                "name": "ESP_CONSOLE_UART_CUSTOM_NUM_1", 
                                "range": null, 
                                "title": "UART1", 
                                "type": "bool"
                            }
                        ], 
                        "depends_on": "ESP_CONSOLE_UART_CUSTOM", 
                        "help": "Due of a ROM bug, UART2 is not supported for console output\nvia ets_printf.\n", 
                        "id": "component-config-common-esp-related-uart-peripheral-to-use-for-console-output-0-1-", 
                        "name": "ESP_CONSOLE_UART_NUM", 
                        "title": "UART peripheral to use for console output (0-1)", 
                        "type": "choice"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": null, 
                        "id": "ESP_CONSOLE_UART_NUM", 
                        "name": "ESP_CONSOLE_UART_NUM", 
                        "range": null, 
                        "title": null, 
                        "type": "int"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "ESP_CONSOLE_UART_CUSTOM", 
                        "help": null, 
                        "id": "ESP_CONSOLE_UART_TX_GPIO", 
                        "name": "ESP_CONSOLE_UART_TX_GPIO", 
                        "range": null, 
                        "title": "UART TX on GPIO#", 
                        "type": "int"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "ESP_CONSOLE_UART_CUSTOM", 
                        "help": null, 
                        "id": "ESP_CONSOLE_UART_RX_GPIO", 
                        "name": "ESP_CONSOLE_UART_RX_GPIO", 
                        "range": null, 
                        "title": "UART RX on GPIO#", 
                        "type": "int"
                    }, 
                    {
                        "children": [], 
                        "depends_on": "!ESP_CONSOLE_UART_NONE", 
                        "help": null, 
                        "id": "ESP_CONSOLE_UART_BAUDRATE", 
                        "name": "ESP_CONSOLE_UART_BAUDRATE", 
                        "range": [
                            1200, 
                            4000000
                        ], 
                        "title": "UART console baud rate", 
                        "type": "int"
                    }, 
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "ESP_INT_WDT", 
                                "help": "The timeout of the watchdog, in miliseconds. Make this higher than the FreeRTOS tick rate.\n", 
                                "id": "ESP_INT_WDT_TIMEOUT_MS", 
                                "name": "ESP_INT_WDT_TIMEOUT_MS", 
                                "range": [
                                    10, 
                                    10000
                                ], 
                                "title": "Interrupt watchdog timeout (ms)", 
                                "type": "int"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "ESP_INT_WDT && !FREERTOS_UNICORE", 
                                "help": "Also detect if interrupts on CPU 1 are disabled for too long.\n", 
                                "id": "ESP_INT_WDT_CHECK_CPU1", 
                                "name": "ESP_INT_WDT_CHECK_CPU1", 
                                "range": null, 
                                "title": "Also watch CPU1 tick interrupt", 
                                "type": "bool"
                            }
                        ], 
                        "depends_on": null, 
                        "help": "This watchdog timer can detect if the FreeRTOS tick interrupt has not been called for a certain time,\neither because a task turned off interrupts and did not turn them on for a long time, or because an\ninterrupt handler did not return. It will try to invoke the panic handler first and failing that\nreset the SoC.\n", 
                        "id": "ESP_INT_WDT", 
                        "name": "ESP_INT_WDT", 
                        "range": null, 
                        "title": "Interrupt watchdog", 
                        "type": "bool"
                    }, 
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "ESP_TASK_WDT", 
                                "help": "If this option is enabled, the Task Watchdog Timer will be configured to\ntrigger the panic handler when it times out. This can also be configured\nat run time (see Task Watchdog Timer API Reference)\n", 
                                "id": "ESP_TASK_WDT_PANIC", 
                                "name": "ESP_TASK_WDT_PANIC", 
                                "range": null, 
                                "title": "Invoke panic handler on Task Watchdog timeout", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "ESP_TASK_WDT", 
                                "help": "Timeout period configuration for the Task Watchdog Timer in seconds.\nThis is also configurable at run time (see Task Watchdog Timer API Reference)\n", 
                                "id": "ESP_TASK_WDT_TIMEOUT_S", 
                                "name": "ESP_TASK_WDT_TIMEOUT_S", 
                                "range": [
                                    1, 
                                    60
                                ], 
                                "title": "Task Watchdog timeout period (seconds)", 
                                "type": "int"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "ESP_TASK_WDT", 
                                "help": "If this option is enabled, the Task Watchdog Timer will watch the CPU0\nIdle Task. Having the Task Watchdog watch the Idle Task allows for detection\nof CPU starvation as the Idle Task not being called is usually a symptom of\nCPU starvation. Starvation of the Idle Task is detrimental as FreeRTOS household\ntasks depend on the Idle Task getting some runtime every now and then.\n", 
                                "id": "ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0", 
                                "name": "ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0", 
                                "range": null, 
                                "title": "Watch CPU0 Idle Task", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "ESP_TASK_WDT && !FREERTOS_UNICORE", 
                                "help": "If this option is enabled, the Task Wtachdog Timer will wach the CPU1\nIdle Task.\n", 
                                "id": "ESP_TASK_WDT_CHECK_IDLE_TASK_CPU1", 
                                "name": "ESP_TASK_WDT_CHECK_IDLE_TASK_CPU1", 
                                "range": null, 
                                "title": "Watch CPU1 Idle Task", 
                                "type": "bool"
                            }
                        ], 
                        "depends_on": null, 
                        "help": "The Task Watchdog Timer can be used to make sure individual tasks are still\nrunning. Enabling this option will cause the Task Watchdog Timer to be\ninitialized automatically at startup. The Task Watchdog timer can be\ninitialized after startup as well (see Task Watchdog Timer API Reference)\n", 
                        "id": "ESP_TASK_WDT", 
                        "name": "ESP_TASK_WDT", 
                        "range": null, 
                        "title": "Initialize Task Watchdog Timer on startup", 
                        "type": "bool"
                    }
                ], 
                "depends_on": null, 
                "id": "component-config-common-esp-related", 
                "title": "Common ESP-related", 
                "type": "menu"
            }, 
            {
                "children": [
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "<choice LOG_DEFAULT_LEVEL>", 
                                "help": null, 
                                "id": "LOG_DEFAULT_LEVEL_NONE", 
                                "name": "LOG_DEFAULT_LEVEL_NONE", 
                                "range": null, 
                                "title": "No output", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice LOG_DEFAULT_LEVEL>", 
                                "help": null, 
                                "id": "LOG_DEFAULT_LEVEL_ERROR", 
                                "name": "LOG_DEFAULT_LEVEL_ERROR", 
                                "range": null, 
                                "title": "Error", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice LOG_DEFAULT_LEVEL>", 
                                "help": null, 
                                "id": "LOG_DEFAULT_LEVEL_WARN", 
                                "name": "LOG_DEFAULT_LEVEL_WARN", 
                                "range": null, 
                                "title": "Warning", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice LOG_DEFAULT_LEVEL>", 
                                "help": null, 
                                "id": "LOG_DEFAULT_LEVEL_INFO", 
                                "name": "LOG_DEFAULT_LEVEL_INFO", 
                                "range": null, 
                                "title": "Info", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice LOG_DEFAULT_LEVEL>", 
                                "help": null, 
                                "id": "LOG_DEFAULT_LEVEL_DEBUG", 
                                "name": "LOG_DEFAULT_LEVEL_DEBUG", 
                                "range": null, 
                                "title": "Debug", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice LOG_DEFAULT_LEVEL>", 
                                "help": null, 
                                "id": "LOG_DEFAULT_LEVEL_VERBOSE", 
                                "name": "LOG_DEFAULT_LEVEL_VERBOSE", 
                                "range": null, 
                                "title": "Verbose", 
                                "type": "bool"
                            }
                        ], 
                        "depends_on": null, 
                        "help": "Specify how much output to see in logs by default.\nYou can set lower verbosity level at runtime using\nesp_log_level_set function.\n\nNote that this setting limits which log statements\nare compiled into the program. So setting this to, say,\n\"Warning\" would mean that changing log level to \"Debug\"\nat runtime will not be possible.\n", 
                        "id": "component-config-log-output-default-log-verbosity", 
                        "name": "LOG_DEFAULT_LEVEL", 
                        "title": "Default log verbosity", 
                        "type": "choice"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": null, 
                        "id": "LOG_DEFAULT_LEVEL", 
                        "name": "LOG_DEFAULT_LEVEL", 
                        "range": null, 
                        "title": null, 
                        "type": "int"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": "Enable ANSI terminal color codes in bootloader output.\n\nIn order to view these, your terminal program must support ANSI color codes.\n", 
                        "id": "LOG_COLORS", 
                        "name": "LOG_COLORS", 
                        "range": null, 
                        "title": "Use ANSI terminal colors in log output", 
                        "type": "bool"
                    }
                ], 
                "depends_on": null, 
                "id": "component-config-log-output", 
                "title": "Log output", 
                "type": "menu"
            }, 
            {
                "children": [
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "SPI_FLASH_VERIFY_WRITE", 
                                "help": "If this option is enabled, if SPI flash write verification fails then a log error line\nwill be written with the address, expected & actual values. This can be useful when\ndebugging hardware SPI flash problems.\n", 
                                "id": "SPI_FLASH_LOG_FAILED_WRITE", 
                                "name": "SPI_FLASH_LOG_FAILED_WRITE", 
                                "range": null, 
                                "title": "Log errors if verification fails", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "SPI_FLASH_VERIFY_WRITE", 
                                "help": "If this option is enabled, any SPI flash write which tries to set zero bits in the flash to\nones will log a warning. Such writes will not result in the requested data appearing identically\nin flash once written, as SPI NOR flash can only set bits to one when an entire sector is erased.\nAfter erasing, individual bits can only be written from one to zero.\n\nNote that some software (such as SPIFFS) which is aware of SPI NOR flash may write one bits as an\noptimisation, relying on the data in flash becoming a bitwise AND of the new data and any existing data.\nSuch software will log spurious warnings if this option is enabled.\n", 
                                "id": "SPI_FLASH_WARN_SETTING_ZERO_TO_ONE", 
                                "name": "SPI_FLASH_WARN_SETTING_ZERO_TO_ONE", 
                                "range": null, 
                                "title": "Log warning if writing zero bits to ones", 
                                "type": "bool"
                            }
                        ], 
                        "depends_on": null, 
                        "help": "If this option is enabled, any time SPI flash is written then the data will be read\nback and verified. This can catch hardware problems with SPI flash, or flash which\nwas not erased before verification.\n", 
                        "id": "SPI_FLASH_VERIFY_WRITE", 
                        "name": "SPI_FLASH_VERIFY_WRITE", 
                        "range": null, 
                        "title": "Verify SPI flash writes", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": "This option enables the following APIs:\n\n- spi_flash_reset_counters\n- spi_flash_dump_counters\n- spi_flash_get_counters\n\nThese APIs may be used to collect performance data for spi_flash APIs\nand to help understand behaviour of libraries which use SPI flash.\n", 
                        "id": "SPI_FLASH_ENABLE_COUNTERS", 
                        "name": "SPI_FLASH_ENABLE_COUNTERS", 
                        "range": null, 
                        "title": "Enable operation counters", 
                        "type": "bool"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": "Enable this flag to use patched versions of SPI flash ROM driver functions.\nThis option is needed to write to flash on ESP32-D2WD, and any configuration\nwhere external SPI flash is connected to non-default pins.\n", 
                        "id": "SPI_FLASH_ROM_DRIVER_PATCH", 
                        "name": "SPI_FLASH_ROM_DRIVER_PATCH", 
                        "range": null, 
                        "title": "Enable SPI flash ROM driver patched functions", 
                        "type": "bool"
                    }, 
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": "<choice SPI_FLASH_DANGEROUS_WRITE>", 
                                "help": null, 
                                "id": "SPI_FLASH_DANGEROUS_WRITE_ABORTS", 
                                "name": "SPI_FLASH_DANGEROUS_WRITE_ABORTS", 
                                "range": null, 
                                "title": "Aborts", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice SPI_FLASH_DANGEROUS_WRITE>", 
                                "help": null, 
                                "id": "SPI_FLASH_DANGEROUS_WRITE_FAILS", 
                                "name": "SPI_FLASH_DANGEROUS_WRITE_FAILS", 
                                "range": null, 
                                "title": "Fails", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": "<choice SPI_FLASH_DANGEROUS_WRITE>", 
                                "help": null, 
                                "id": "SPI_FLASH_DANGEROUS_WRITE_ALLOWED", 
                                "name": "SPI_FLASH_DANGEROUS_WRITE_ALLOWED", 
                                "range": null, 
                                "title": "Allowed", 
                                "type": "bool"
                            }
                        ], 
                        "depends_on": null, 
                        "help": "SPI flash APIs can optionally abort or return a failure code\nif erasing or writing addresses that fall at the beginning\nof flash (covering the bootloader and partition table) or that\noverlap the app partition that contains the running app.\n\nIt is not recommended to ever write to these regions from an IDF app,\nand this check prevents logic errors or corrupted firmware memory from\ndamaging these regions.\n\nNote that this feature *does not* check calls to the esp_rom_xxx SPI flash\nROM functions. These functions should not be called directly from IDF\napplications.\n", 
                        "id": "component-config-spi-flash-driver-writing-to-dangerous-flash-regions", 
                        "name": "SPI_FLASH_DANGEROUS_WRITE", 
                        "title": "Writing to dangerous flash regions", 
                        "type": "choice"
                    }, 
                    {
                        "children": [], 
                        "depends_on": null, 
                        "help": "The implementation of SPI flash has been greatly changed in IDF v4.0.\nEnable this option to use the legacy implementation.\n", 
                        "id": "SPI_FLASH_USE_LEGACY_IMPL", 
                        "name": "SPI_FLASH_USE_LEGACY_IMPL", 
                        "range": null, 
                        "title": "Use the legacy implementation before IDF v4.0", 
                        "type": "bool"
                    }, 
                    {
                        "children": [
                            {
                                "children": [], 
                                "depends_on": null, 
                                "help": "Enable this to support auto detection of ISSI chips if chip vendor not directly\ngiven by ``chip_drv`` member of the chip struct. This adds support for variant\nchips, however will extend detecting time.\n", 
                                "id": "SPI_FLASH_SUPPORT_ISSI_CHIP", 
                                "name": "SPI_FLASH_SUPPORT_ISSI_CHIP", 
                                "range": null, 
                                "title": "ISSI", 
                                "type": "bool"
                            }, 
                            {
                                "children": [], 
                                "depends_on": null, 
                                "help": "Enable this to support auto detection of GD (GigaDevice) chips if chip vendor not\ndirectly given by ``chip_drv`` member of the chip struct. If you are using Wrover\nmodules, please don't disable this, otherwise your flash may not work in 4-bit\nmode.\n\nThis adds support for variant chips, however will extend detecting time and image\nsize. Note that the default chip driver supports the GD chips with product ID\n60H.\n", 
                                "id": "SPI_FLASH_SUPPORT_GD_CHIP", 
                                "name": "SPI_FLASH_SUPPORT_GD_CHIP", 
                                "range": null, 
                                "title": "GigaDevice", 
                                "type": "bool"
                            }
                        ], 
                        "depends_on": null, 
                        "id": "component-config-spi-flash-driver-auto-detect-flash-chips", 
                        "title": "Auto-detect flash chips", 
                        "type": "menu"
                    }
                ], 
                "depends_on": null, 
                "id": "component-config-spi-flash-driver", 
                "title": "SPI Flash driver", 
                "type": "menu"
            }
        ], 
        "depends_on": null, 
        "id": "component-config", 
        "title": "Component config", 
        "type": "menu"
    }, 
    {
        "children": [
            {
                "children": [], 
                "depends_on": null, 
                "help": "Soc, esp32, and driver components, the most common\ncomponents. Some header of these components are included\nimplicitly by headers of other components before IDF v4.0.\nIt's not required for high-level components, but still\nincluded through long header chain everywhere.\n\nThis is harmful to the modularity. So it's changed in IDF\nv4.0.\n\nYou can still include these headers in a legacy way until it\nis totally deprecated by enable this option.\n", 
                "id": "LEGACY_INCLUDE_COMMON_HEADERS", 
                "name": "LEGACY_INCLUDE_COMMON_HEADERS", 
                "range": null, 
                "title": "Include headers accross components as before IDF v4.0", 
                "type": "bool"
            }
        ], 
        "depends_on": null, 
        "id": "compatibility-options", 
        "title": "Compatibility options", 
        "type": "menu"
    }
]